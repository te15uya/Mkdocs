<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>1.Linux系统编程入门 - Tetsuya's MkDocs</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "1.Linux\u7cfb\u7edf\u7f16\u7a0b\u5165\u95e8";
        var mkdocs_page_input_path = "Linux504\\01Linux\u7cfb\u7edf\u7f16\u7a0b\u5165\u95e8.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Tetsuya's MkDocs
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Linux504</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">1.Linux系统编程入门</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_2">系统配置</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#vs-code">VS code</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#gcc">GCC</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_3">说明</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#gcc_1">安装gcc</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#gcc_2">gcc工作流程</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#gcc_3">gcc常用参数选项</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Tetsuya's MkDocs</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
          <li>Linux504 &raquo;</li>
      <li>1.Linux系统编程入门</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1">准备工作</h1>
<h2 id="_2">系统配置</h2>
<ol>
<li>
<p>在虚拟机中安装Linux系统，本项目采用<code>VMware Workstation 16.1.2</code>和<code>Ubuntu 18.04</code>，本机系统为<code>Win 10</code></p>
</li>
<li>
<p>更新<code>Ubuntu 18.04</code>源并安装<code>open-vm-tools</code></p>
</li>
<li>
<p>进入<code>/etc/apt/sources.list</code> 修改为国内镜像源（速度快），全部删除，替换为下述内容，如果更新报错，将<code>https</code>换成<code>http</code></p>
<p>```shell
  # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
  deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
  # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
  deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
  # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
  deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
  # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
  deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
  # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</p>
<p># 预发布软件源，不建议启用
  # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
  # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
  ```</p>
</li>
<li>
<p>更新系统源：</p>
<p><code>shell
  # update 是同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包
  sudo apt update
  # upgrade 是升级已安装的所有软件包(可选)
  # sudo apt upgrade</code></p>
</li>
<li>
<p>安装<code>open-vm-tools</code>：<code>sudo apt install open-vm-tools</code></p>
</li>
<li>
<p>~~如果要实现文件夹共享，需要安装<code>open-vm-tools-dkms</code>：<code>sudo apt install open-vm-tools-dkms</code>~~=&gt;清华源找不到<code>open-vm-tools-dkms</code>，不安装不影响</p>
</li>
<li>
<p>桌面环境还需要安装<code>open-vm-tools-desktop</code>以支持双向拖放文件：<code>sudo apt install open-vm-tools-desktop</code></p>
</li>
<li>
<p>重启（使用<code>VMware</code>自带重启，使用<code>reboot</code>重启可能失败）后成功进行拖拽复制</p>
</li>
</ol>
<p>注：<a href="https://blog.csdn.net/hhdhz/article/details/87922794">参考链接</a></p>
<ol>
<li>在<code>Ubuntu 18.10</code>安装必要组件</li>
</ol>
<p>```shell
   # 安装Vim环境
   sudo apt install vim</p>
<p># 用于远程连接虚拟机
   sudo apt install openssh-server</p>
<p># 用于查看IP地址
   sudo apt install net-tools</p>
<p># 树形查看文件夹内容
   sudo apt install tree
   ```</p>
<h2 id="vs-code">VS code</h2>
<ol>
<li>
<p>安装<code>Remote Development</code>插件</p>
</li>
<li>
<p>在Linux中使用<code>ifconfig</code>查看<code>ip地址</code></p>
</li>
<li>
<p>按下图步骤设置<code>config</code>文件</p>
</li>
</ol>
<p><img alt="image-20210831142010206" src="image-20210831142010206.png" /></p>
<ol>
<li><code>config</code>内容如下</li>
</ol>
<p><code>shell
   # Read more about SSH config files: https://linux.die.net/man/5/ssh_config
   Host 自定义名称
       HostName 远程服务器IP
       User 远程服务器用户名</code></p>
<h2 id="gcc">GCC</h2>
<h3 id="_3">说明</h3>
<p>本部分笔记及源码出自<code>slide/01Linux系统编程入门/01 GCC</code></p>
<h3 id="gcc_1">安装<code>gcc</code></h3>
<p>命令：<code>sudo apt install gcc g++</code>，本项目安装版本为：<code>7.5.0</code></p>
<h3 id="gcc_2">gcc工作流程</h3>
<p><img alt="image-20210831132508825" src="image-20210831132508825.png" /></p>
<h3 id="gcc_3">gcc常用参数选项</h3>
<p><img alt="image-20210831132654506" src="image-20210831132654506.png" /></p>
<p><img alt="image-20210831135954037" src="image-20210831135954037.png" /></p>
<ul>
<li>
<p><code>-D</code>实例</p>
</li>
<li>
<p>源程序</p>
<p>```c</p>
<h1 id="include">include<stdio.h></h1>
<p>int main()
{</p>
<h1 id="if-debug">if DEBUG</h1>
<pre><code>printf("Debug\n");
</code></pre>
<h1 id="endif">endif</h1>
<pre><code>printf("hello, world\n");
return 0;
</code></pre>
<p>}
```</p>
</li>
<li>
<p>编译命令1：</p>
<p>```shell
gcc test.c -o test
./test</p>
<h1 id="_4">输出</h1>
<p>hello, world
```</p>
</li>
<li>
<p>编译命令2：</p>
<p>```shell
gcc test.c -o test -D DEBUG
./test</p>
<h1 id="_5">输出</h1>
<p>Debug
hello, world
```</p>
</li>
</ul>
<h3 id="gccg">gcc与g++区别</h3>
<ul>
<li><code>gcc</code> 和 <code>g++</code> 都是<code>GNU(组织)</code>的一个编译器</li>
<li><strong>误区一</strong>：<code>gcc</code> 只能编译 c 代码，g++ 只能编译 c++ 代码</li>
<li>后缀为<code>.c</code> 的，<code>gcc</code> 把它当作是 C 程序，而 <code>g++</code> 当作是 <code>c++</code> 程序</li>
<li>后缀为 <code>.cpp</code> 的，两者都会认为是 <code>C++</code> 程序，<code>C++</code> 的语法规则更加严谨一些</li>
<li>编译阶段，<code>g++</code> 会调用 <code>gcc</code>，对于 <code>C++</code> 代码，两者是等价的，但是因为 <code>gcc</code> 命令不能自动和 <code>C++</code> 程序使用的库联接，所以通常用 <code>g++</code> 来完成链接，为了统一起见，干脆编译/链接统统用 <code>g++</code> 了，这就给人一种错觉，好像 <code>cpp</code> 程序只能用 <code>g++</code> 似的</li>
<li><strong>误区二</strong>：<code>gcc</code> 不会定义 <code>__cplusplus</code> 宏，而 <code>g++</code> 会 </li>
<li>实际上，这个宏只是标志着编译器将会把代码按 C 还是 C++ 语法来解释</li>
<li>如上所述，如果后缀为<code>.c</code>，并且采用 <code>gcc</code> 编译器，则该宏就是未定义的，否则，就是已定义</li>
<li><strong>误区三</strong>：编译只能用 <code>gcc</code>，链接只能用 <code>g++</code></li>
<li>严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以用 <code>gcc/g++</code>，而链接可以用 <code>g++</code> 或者 <code>gcc -lstdc++</code></li>
<li><code>gcc</code> 命令不能自动和C++程序使用的库联接，所以通常使用 <code>g++</code> 来完成链接。但在编译阶段，<code>g++</code> 会自动调用 <code>gcc</code>，二者等价</li>
</ul>
<h1 id="linux">Linux系统编程基础知识</h1>
<h2 id="_6">静态库与动态库</h2>
<h3 id="_7">说明</h3>
<p>本部分笔记及源码出自<code>slide/01Linux系统编程入门/02 静态库与动态库</code></p>
<h3 id="_8">库</h3>
<ul>
<li>库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些<strong>可以直接拿来用的变量、函数或类</strong></li>
<li>库是特殊的一种程序，编写库的程序和编写一般的程序区别不大，只是<strong>库不能单独运行</strong></li>
<li>库文件有两种，<code>静态库</code>和<code>动态库（共享库）</code>。区别是：</li>
<li><strong>静态库</strong>在程序的链接阶段被复制到了程序中</li>
<li><strong>动态库</strong>在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用</li>
<li>库的好处：<strong>代码保密</strong> 和<strong>方便部署和分发</strong></li>
</ul>
<h3 id="_9">静态库的制作</h3>
<ul>
<li>规则</li>
</ul>
<p><img alt="image-20210831163546031" src="image-20210831163546031.png" /></p>
<ul>
<li>示例：有如下图所示文件(其中每个分文件用于实现四则运算)，将其打包为<strong>静态库</strong></li>
</ul>
<p><img alt="image-20210831164707648" src="image-20210831164707648.png" /></p>
<ol>
<li>
<p>生成<code>.o</code>文件：<code>gcc -c 文件名</code></p>
<p><img alt="image-20210831164903714" src="image-20210831164903714.png" /></p>
</li>
<li>
<p>将<code>.o</code>文件打包：<code>ar rcs libxxx.a xx1.o xx2.o</code></p>
<p><img alt="image-20210831165142693" src="image-20210831165142693.png" /></p>
</li>
</ol>
<h3 id="_10">静态库的使用</h3>
<ul>
<li>需要提供<strong>静态库文件和相应的头文件</strong>，有如下结构文件，其中<code>main.c</code>测试文件</li>
</ul>
<p><img alt="image-20210831170033041" src="image-20210831170033041.png" /></p>
<p>```c
  // main.c
  #include <stdio.h>
  #include "head.h"</p>
<p>int main()
  {
      int a = 20;
      int b = 12;
      printf("a = %d, b = %d\n", a, b);
      printf("a + b = %d\n", add(a, b));
      printf("a - b = %d\n", subtract(a, b));
      printf("a * b = %d\n", multiply(a, b));
      printf("a / b = %f\n", divide(a, b));
      return 0;
  }
  ```</p>
<ul>
<li>
<p>编译运行：<code>gcc main.c -o app -I ./include -l calc -L ./lib</code></p>
</li>
<li>
<p><code>-I ./include</code>：指定头文件目录，如果不指定，出现以下错误</p>
<p><img alt="image-20210831170715090" src="image-20210831170715090.png" /></p>
</li>
<li>
<p><code>-l calc</code>：指定静态库名称，如果不指定，出现以下错误</p>
<p><img alt="image-20210831170816127" src="image-20210831170816127.png" /></p>
</li>
<li>
<p><code>-L ./lib</code>：指定静态库位置，如果不指定，出现以下错误</p>
<p><img alt="image-20210831170844743" src="image-20210831170844743.png" /></p>
</li>
<li>
<p><strong>正确执行</strong>（成功生成<code>app</code>可执行文件）</p>
<p><img alt="image-20210831170923394" src="image-20210831170923394.png" /></p>
</li>
<li>
<p>测试程序</p>
<p><img alt="image-20210831193122578" src="image-20210831193122578.png" /></p>
</li>
</ul>
<h3 id="_11">动态库的制作</h3>
<ul>
<li>规则</li>
</ul>
<p><img alt="image-20210831171945803" src="image-20210831171945803.png" /></p>
<ul>
<li>示例：有如下图所示文件(其中每个分文件用于实现四则运算)，将其打包为<strong>动态库</strong></li>
</ul>
<p><img alt="image-20210831164707648" src="image-20210831164707648.png" /></p>
<ol>
<li>
<p>生成<code>.o</code>文件：<code>gcc -c -fpic 文件名</code></p>
<p><img alt="image-20210831173502435" src="image-20210831173502435.png" /></p>
</li>
<li>
<p>将<code>.o</code>文件打包：<code>gcc -shared xx1.o xx2.o -o libxxx.so</code></p>
<p><img alt="image-20210831173600480" src="image-20210831173600480.png" /></p>
</li>
</ol>
<h3 id="_12">动态库的使用</h3>
<ul>
<li>
<p>需要提供<strong>动态库文件和相应的头文件</strong></p>
</li>
<li>
<p>定位动态库（<strong>原因见工作原理-&gt;如何定位共享库文件</strong>，其中路径为动态库所在位置）</p>
</li>
<li>
<p>方法一：修改环境变量，<strong>当前终端生效</strong>，退出当前终端失效</p>
<p><code>shell
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/u/Desktop/Linux/calc/lib</code></p>
</li>
<li>
<p>方法二：修改环境变量，用户级别永久配置</p>
<p>```shell</p>
<h1 id="bashrc">修改~/.bashrc</h1>
<p>vim ~/.bashrc</p>
<h1 id="bashrc_1">在~/.bashrc中添加下行，保存退出</h1>
<p>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/u/Desktop/Linux/calc/lib</p>
<h1 id="_13">使修改生效</h1>
<p>source ~/.bashrc
```</p>
</li>
<li>
<p>方法三：修改环境变量，系统级别永久配置</p>
<p>```shell</p>
<h1 id="etcprofile">修改/etc/profile</h1>
<p>sudo vim /etc/profile</p>
<h1 id="bashrc_2">在~/.bashrc中添加下行，保存退出</h1>
<p>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/u/Desktop/Linux/calc/lib</p>
<h1 id="_14">使修改生效</h1>
<p>source /etc/profile
```</p>
</li>
<li>
<p>方法四：修改<code>/etc/ld.so.cache文件列表</code></p>
<p>```shell</p>
<h1 id="etcldsoconf">修改/etc/ld.so.conf</h1>
<p>sudo vim /etc/ld.so.conf</p>
<h1 id="etcldsoconf_1">在/etc/ld.so.conf中添加下行，保存退出</h1>
<p>/home/u/Desktop/Linux/calc/lib</p>
<h1 id="_15">更新配置</h1>
<p>sudo ldconfig
```</p>
</li>
<li>
<p>有如下结构文件，其中<code>main.c</code>测试文件</p>
</li>
</ul>
<p><img alt="image-20210831173858257" src="image-20210831173858257.png" /></p>
<ul>
<li>编译运行：<code>gcc main.c -o app -I ./include -l calc -L ./lib</code></li>
</ul>
<p><img alt="image-20210831193101168" src="image-20210831193101168.png" /></p>
<ul>
<li>测试程序</li>
</ul>
<p><img alt="image-20210831193122578" src="image-20210831193122578.png" /></p>
<ul>
<li>如果不将动态库文件绝对路径加入环境变量，则会出现以下错误</li>
</ul>
<p><img alt="image-20210831174331780" src="image-20210831174331780.png" /></p>
<h3 id="_16">工作原理</h3>
<ul>
<li>
<p>静态库：<code>GCC</code> 进行链接时，会把静态库中代码打包到可执行程序中</p>
</li>
<li>
<p>动态库：<code>GCC</code> 进行链接时，动态库的代码不会被打包到可执行程序中</p>
</li>
<li>
<p>程序启动之后，动态库会被动态加载到内存中，通过 <code>ldd （list dynamic dependencies）</code>命令检查动态库依赖关系</p>
</li>
</ul>
<p><img alt="image-20210831174842063" src="image-20210831174842063.png" /></p>
<ul>
<li>
<p>如何定位共享库文件呢？</p>
</li>
<li>
<p>当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道<strong>绝对路径</strong>。此时就需要系统的动态载入器来获取该绝对路径</p>
</li>
<li>对于<code>elf格式</code>的可执行程序，是由<code>ld-linux.so</code>来完成的，它先后搜索<code>elf文件</code>的 <code>DT_RPATH</code>段 =&gt; <code>环境变量LD_LIBRARY_PATH</code> =&gt; <code>/etc/ld.so.cache文件列表</code> =&gt; <code>/lib/</code>，<code>usr/lib</code>目录找到库文件后将其载入内存</li>
</ul>
<h3 id="_17">静态库和动态库的对比</h3>
<h4 id="_18">程序编译成可执行程序的过程</h4>
<p><img alt="image-20210902092607878" src="image-20210902092607878.png" /></p>
<h4 id="_19">静态库制作过程</h4>
<p><img alt="image-20210902092645051" src="image-20210902092645051.png" /></p>
<h4 id="_20">动态库制作过程</h4>
<p><img alt="image-20210902092702345" src="image-20210902092702345.png" /></p>
<h4 id="_21">静态库的优缺点</h4>
<p><img alt="image-20210902092725852" src="image-20210902092725852.png" /></p>
<h4 id="_22">动态库的优缺点</h4>
<p><img alt="image-20210902092749213" src="image-20210902092749213.png" /></p>
<h2 id="makefile">Makefile</h2>
<h3 id="_23">说明</h3>
<p>本部分笔记及源码出自<code>slide/01Linux系统编程入门/03 Makefile</code></p>
<h3 id="_24">概念及安装</h3>
<ul>
<li>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，<code>Makefile</code> 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 <code>Makefile</code> 文件就像一个 <code>Shell</code> 脚本一样，也可以执行操作系统的命令</li>
<li><code>Makefile</code> 带来的好处就是“自动化编译” ，一旦写好，只需要一个 <code>make</code> 命令，整个工程完全自动编译，极大的提高了软件开发的效率。</li>
<li><code>make</code> 是一个命令工具，是一个解释 <code>Makefile</code> 文件中指令的命令工具，一般来说，大多数的 <code>IDE</code> 都有这个命令，比如 Delphi 的 <code>make</code>，Visual C++ 的 <code>nmake</code>，Linux 下 GNU 的 <code>make</code></li>
<li>安装：<code>sudo apt install make</code>，安装时会安装<code>man 手册</code></li>
</ul>
<h3 id="makefile_1">Makefile 文件命名和规则</h3>
<ul>
<li>
<p>文件命名：<code>makefile</code> 或者 <code>Makefile</code></p>
</li>
<li>
<p><code>Makefile</code> 规则</p>
</li>
<li>
<p>一个 <code>Makefile</code> 文件中可以有一个或者多个规则</p>
<p><img alt="image-20210902093603940" src="image-20210902093603940.png" /></p>
<ul>
<li><strong>目标</strong>：最终要生成的文件（伪目标除外）</li>
<li><strong>依赖</strong>：生成目标所需要的文件或是目标</li>
<li><strong>命令</strong>：通过执行命令对依赖操作生成目标（命令前必须 Tab 缩进）</li>
</ul>
</li>
<li>
<p><code>Makefile</code> 中的其它规则一般都是为第一条规则服务的。</p>
</li>
</ul>
<h3 id="makefile_2">Makefile编写方式</h3>
<h4 id="_25">说明</h4>
<p>假设有如下文件</p>
<p><img alt="image-20210902100556519" src="image-20210902100556519.png" /></p>
<h4 id="makefile_3">方式一：Makefile+直接编译链接（不推荐）</h4>
<pre><code class="language-makefile">app:add.c div.c multi.c sub.c main.c
    gcc add.c div.c multi.c sub.c main.c -o app
</code></pre>
<p><img alt="image-20210902101930762" src="image-20210902101930762.png" /></p>
<h4 id="makefile_4">方式二：Makefile+编译+链接</h4>
<pre><code class="language-makefile">app:add.o div.o multi.o sub.o main.o
    gcc add.o div.o multi.o sub.o main.o -o app

add.o:add.c
    gcc -c add.c -o add.o

div.o:div.c
    gcc -c div.c -o div.o

multi.o:multi.c
    gcc -c multi.c -o multi.o

sub.o:sub.c
    gcc -c sub.c -o sub.o

main.o:main.c
    gcc -c main.c -o main.o
</code></pre>
<p><img alt="image-20210902101856277" src="image-20210902101856277.png" /></p>
<h4 id="makefile_5">方式三：Makefile+变量</h4>
<h5 id="_26">知识点</h5>
<ul>
<li>
<p>自定义变量：<code>变量名=变量值</code>，如<code>var=hello</code></p>
</li>
<li>
<p>预定义变量</p>
</li>
<li>
<p><code>AR</code> : 归档维护程序的名称，默认值为 ar</p>
</li>
<li>
<p><code>CC</code>: C 编译器的名称，默认值为 cc</p>
</li>
<li>
<p><code>CXX</code> : C++ 编译器的名称，默认值为 g++</p>
</li>
<li>
<p><code>$@</code> : 目标的完整名称</p>
</li>
<li>
<p><code>$&lt;</code> : 第一个依赖文件的名称</p>
</li>
<li>
<p><code>$^</code>: 所有的依赖文件</p>
</li>
<li>
<p>示例</p>
<p><img alt="image-20210902095418237" src="image-20210902095418237.png" /></p>
</li>
<li>
<p>获取变量的值：<code>$(变量名)</code>，如<code>$(var)</code></p>
</li>
</ul>
<h5 id="_27">示例</h5>
<pre><code class="language-makefile">src=add.o div.o multi.o sub.o main.o
target=app
$(target):$(src)
    $(CC) $^ -o $@

add.o:add.c
    $(CC) -c $^ -o $@

div.o:div.c
    $(CC) -c $^ -o $@

multi.o:multi.c
    $(CC) -c $^ -o $@

sub.o:sub.c
    $(CC) -c $^ -o $@

main.o:main.c
    $(CC) -c $^ -o $@
</code></pre>
<p><img alt="image-20210902103929268" src="image-20210902103929268.png" /></p>
<h4 id="makefile_6">方式四：Makefile+模式匹配</h4>
<h5 id="_28">知识点</h5>
<p>当所要编译的文件过多时，使用模式匹配能够简化操作</p>
<p><img alt="image-20210902095522095" src="image-20210902095522095.png" /></p>
<h5 id="_29">示例</h5>
<pre><code class="language-makefile">src=add.o div.o multi.o sub.o main.o
target=app
$(target):$(src)
    $(CC) $^ -o $@

%.o:%.c
    $(CC) -c $&lt; -o $@
</code></pre>
<p><img alt="image-20210902104314203" src="image-20210902104314203.png" /></p>
<h4 id="makefile_7">方法五：Makefile + 函数</h4>
<h5 id="_30">知识点</h5>
<ul>
<li>
<p><code>$(wildcard PATTERN...)</code></p>
</li>
<li>
<p>功能：获取指定目录下指定类型的文件列表</p>
</li>
<li>
<p>参数：PATTERN 指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔</p>
</li>
<li>
<p>返回：得到的若干个文件的文件列表，文件名之间使用空格间隔</p>
</li>
<li>
<p>示例</p>
<p><img alt="image-20210902100119333" src="image-20210902100119333.png" /></p>
</li>
<li>
<p><code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</code></p>
</li>
<li>
<p>功能：查找<code>&lt;text&gt;</code>中的单词(单词以“空格”、“Tab”或“回车”“换行”分隔)是否符合模式<code>&lt;pattern&gt;</code>，如果匹配的话，则以<code>&lt;replacement&gt;</code>替换</p>
</li>
<li>
<p><code>&lt;pattern&gt;</code>可以包括通配符<code>%</code>，表示任意长度的字串。如果<code>&lt;replacement&gt;</code>中也包含<code>%</code>，那么，<code>&lt;replacement&gt;</code>中的这个<code>%</code>将是<code>&lt;pattern&gt;</code>中的那个%所代表的字串。(可以用<code>\</code>来转义，以<code>\%</code>来表示真实含义的<code>%</code>字符)</p>
</li>
<li>
<p>返回：函数返回被替换过后的字符串</p>
</li>
<li>
<p>示例</p>
<p><img alt="image-20210902100350848" src="image-20210902100350848.png" /></p>
</li>
</ul>
<h5 id="_31">示例</h5>
<pre><code class="language-makefile">src=$(wildcard ./*.c)
objs=$(patsubst %.c, %.o, $(src))
target=app
$(target):$(objs)
    $(CC) $^ -o $@

%.o:%.c
    $(CC) -c $&lt; -o $@
</code></pre>
<p><img alt="image-20210902104748931" src="image-20210902104748931.png" /></p>
<h3 id="_32">清除中间文件</h3>
<pre><code class="language-makefile">src=$(wildcard ./*.c)
objs=$(patsubst %.c, %.o, $(src))
target=app
$(target):$(objs)
    $(CC) $^ -o $@

%.o:%.c
    $(CC) -c $&lt; -o $@

clean:
    rm *.o
</code></pre>
<p><img alt="image-20210902104842411" src="image-20210902104842411.png" /></p>
<h3 id="_33">工作原理</h3>
<ul>
<li>命令在执行之前，需要先检查规则中的依赖是否存在</li>
<li>如果存在，执行命令</li>
<li>如果不存在，向下检查其它的规则，检查有没有一个规则是用来生成这个依赖的，如果找到了，则执行该规则中的命令</li>
<li>检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间</li>
<li>如果依赖的时间比目标的时间晚，需要重新生成目标</li>
<li>
<p>如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行</p>
</li>
<li>
<p>示例</p>
</li>
<li>
<p>当修改<code>main.c</code>且重新<code>make</code>时，如下</p>
<p><img alt="image-20210902105119451" src="image-20210902105119451.png" /></p>
</li>
<li>
<p>当不做任何修改且重新<code>make</code>时，如下</p>
<p><img alt="image-20210902105057184" src="image-20210902105057184.png" /></p>
</li>
</ul>
<h2 id="gdb">GDB调试</h2>
<h3 id="_34">说明</h3>
<p>本部分笔记及源码出自<code>slide/01Linux系统编程入门/04 GDB调试</code></p>
<h3 id="_35">概念</h3>
<ul>
<li><code>GDB</code> 是由 GNU 软件系统社区提供的调试工具，同 <code>GCC</code> 配套组成了一套完整的开发环境，<code>GDB</code> 是 Linux 和许多类 Unix 系统中的标准开发环境</li>
<li>一般来说，<code>GDB</code> 主要帮助你完成下面四个方面的功能</li>
<li>启动程序，可以按照自定义的要求随心所欲的运行程序</li>
<li>可让被调试的程序在所指定的调置的断点处停住（断点可以是条件表达式）</li>
<li>当程序被停住时，可以检查此时程序中所发生的事</li>
<li>可以改变程序，将一个 BUG 产生的影响修正从而测试其他 BUG</li>
</ul>
<h3 id="_36">准备工作</h3>
<ul>
<li>使用以下命令编译：<code>gcc -g -Wall program.c -o program</code></li>
<li>通常，在为调试而编译时，我们会<strong>关掉编译器的优化选项</strong>（<code>-O</code>）， 并打开<strong>调试选项</strong>（<code>-g</code>）。另外，<code>-Wall</code>在尽量不影响程序行为的情况下选项打开所有warning，也可以发现许多问题，避免一些不必要的 BUG</li>
<li>
<p><code>-g</code> 选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 <code>gdb</code> 能找到源文件</p>
</li>
<li>
<p>注：当在 <code>gdb</code> 中直接使用<code>回车</code>时，会默认执行上一条命令</p>
</li>
</ul>
<h3 id="_37">常用命令</h3>
<h4 id="_38">说明</h4>
<ul>
<li><code>启动与退出</code>至<code>查看当前文件代码</code>使用<code>test.c</code></li>
<li>后续内容使用课件中其他源程序</li>
</ul>
<h4 id="_39">启动与退出</h4>
<ul>
<li>启动：<code>gdb 可执行程序</code></li>
<li>退出：<code>quit/q</code></li>
</ul>
<p><img alt="image-20210903103104338" src="image-20210903103104338.png" /></p>
<h4 id="_40">给程序设置参数/获取设置参数</h4>
<ul>
<li>设置参数：<code>set args 10 20</code></li>
<li>获取设置参数：<code>show args</code></li>
</ul>
<pre><code class="language-c">// test.c 源码
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int test(int a);

int main(int argc, char* argv[]) {
    int a, b;
    printf(&quot;argc = %d\n&quot;, argc);

    if(argc &lt; 3) {
        a = 10;
        b = 30;
    } else {
        a = atoi(argv[1]);
        b = atoi(argv[2]);
    }
    printf(&quot;a = %d, b = %d\n&quot;, a, b);
    printf(&quot;a + b = %d\n&quot;, a + b);

    for(int i = 0; i &lt; a; ++i) {
        printf(&quot;i = %d\n&quot;, i);
        // 函数调用
        int res = test(i);
        printf(&quot;res value: %d\n&quot;, res);
    }

    printf(&quot;THE END !!!\n&quot;);
    return 0;
}

int test(int a) {
    int num = 0;
    for(int i = 0; i &lt; a; ++i) {
        num += i;
    }
    return num;
}
</code></pre>
<p><img alt="image-20210903103228384" src="image-20210903103228384.png" /></p>
<h4 id="gdb_1">GDB使用帮助</h4>
<ul>
<li><code>help</code></li>
</ul>
<p><img alt="image-20210903103520671" src="image-20210903103520671.png" /></p>
<h4 id="_41">查看当前文件代码</h4>
<ul>
<li>从默认位置显示：<code>list/l</code></li>
</ul>
<p><img alt="image-20210903103920656" src="image-20210903103920656.png" /></p>
<ul>
<li>从指定的行显示：<code>list/l 行号</code></li>
</ul>
<p><img alt="image-20210903104039928" src="image-20210903104039928.png" /></p>
<ul>
<li>从指定的函数显示：<code>list/l 行号</code></li>
</ul>
<p><img alt="image-20210903104052483" src="image-20210903104052483.png" /></p>
<ul>
<li>注：<strong>查看时会显示前后文</strong></li>
</ul>
<h4 id="_42">查看非当前文件代码</h4>
<ul>
<li>编译运行并使用<code>gdb main</code></li>
</ul>
<p><img alt="image-20210903104949112" src="image-20210903104949112.png" /></p>
<ul>
<li>从指定文件指定的行显示：<code>list/l 文件名:行号</code></li>
</ul>
<p><img alt="image-20210903105035366" src="image-20210903105035366.png" /></p>
<ul>
<li>从指定文件指定的函数显示：<code>list/l 文件名:函数名</code></li>
</ul>
<p><img alt="image-20210903105105909" src="image-20210903105105909.png" /></p>
<h4 id="_43">查看及设置显示的行数</h4>
<ul>
<li>查看显示的行数：<code>show list/listsize</code></li>
<li>设置显示的行数：<code>set list/listsize</code></li>
</ul>
<p><img alt="image-20210903105356344" src="image-20210903105356344.png" /></p>
<h4 id="_44">断点操作</h4>
<ul>
<li>
<p>查看断点：<code>i/info b/break</code></p>
</li>
<li>
<p>设置一般断点</p>
</li>
<li><code>b/break 行号</code></li>
<li><code>b/break 函数名</code></li>
<li><code>b/break 文件名:行号</code></li>
<li><code>b/break 文件名:函数</code></li>
<li>设置条件断点（一般用在循环的位置）：<code>b/break 10 if i==5</code></li>
</ul>
<p><img alt="image-20210903110417653" src="image-20210903110417653.png" /></p>
<ul>
<li>删除断点：<code>d/del/delete 断点编号</code></li>
<li>设置断点无效：<code>dis/disable 断点编号</code></li>
<li>设置断点生效：<code>ena/enable 断点编号</code></li>
</ul>
<p><img alt="image-20210903110544093" src="image-20210903110544093.png" /></p>
<h4 id="_45">调试操作</h4>
<ul>
<li>运行 <code>GDB</code> 程序</li>
<li>程序停在第一行：<code>start</code></li>
<li>遇到断点才停：<code>run</code></li>
<li>继续运行，到下一个断点停：<code>c/continue</code></li>
<li>向下执行一行代码（不会进入函数体）：<code>n/next</code></li>
<li>变量操作</li>
<li>打印变量值：<code>p/print 变量名</code></li>
<li>打印变量类型：<code>ptype 变量名</code></li>
<li>向下单步调试（遇到函数进入函数体）</li>
<li><code>s/step</code></li>
<li>跳出函数体：<code>finish</code></li>
<li>自动变量操作</li>
<li>自动打印指定变量的值：<code>display 变量名</code></li>
<li>查看自动变量：<code>i/info display</code></li>
<li>取消自动变量：<code>undisplay 编号</code></li>
<li>其它操作</li>
<li>设置变量值：<code>set var 变量名=变量值 （循环中用的较多）</code></li>
<li>跳出循环：<code>until</code></li>
</ul>
<h2 id="io">文件IO</h2>
<h3 id="_46">说明</h3>
<ul>
<li>
<p>本部分笔记及源码出自<code>slide/01Linux系统编程入门/05 文件IO</code></p>
</li>
<li>
<p>在<code>Linux</code>中使用<code>man 2 API名</code>查看<strong>Linux系统API</strong>，<code>man 3 API名</code>查看<strong>标准C库API</strong></p>
</li>
<li>
<p><code>man 2 open</code></p>
<p><img alt="image-20210905161448175" src="image-20210905161448175.png" /></p>
</li>
<li>
<p><code>man 3 fopen</code></p>
<p><img alt="image-20210905161518280" src="image-20210905161518280.png" /></p>
</li>
</ul>
<h3 id="c-io">标准 C 库 IO 函数</h3>
<p><img alt="image-20210905151717853" src="image-20210905151717853.png" /></p>
<h3 id="c-io-linux-io">标准 C 库 IO 和 Linux 系统 IO 的关系</h3>
<p><img alt="image-20210905151735234" src="image-20210905151735234.png" /></p>
<h3 id="_47">虚拟地址空间</h3>
<ul>
<li>虚拟地址空间是为了解决内存加载问题</li>
<li>问题1：假设实际内存为<code>4G</code>，此时共有<code>1G</code>、<code>2G</code>、<code>2G</code>三个程序，如果直接加载，那么第三个程序由于内存不足而无法执行</li>
<li>
<p>问题2：当问题1的<code>1G</code>程序执行完后，释放内存，第三个程序可以执行，但此时内存空间不连续</p>
</li>
<li>
<p>对于32位机器来说，大小约为$2^{32}$，即<code>4G</code>左右，对于64位机器来说，，大小约为$2^{48}$，即<code>256T</code>左右</p>
</li>
<li>通过<code>CPU中的MMU(内存管理单元)</code>将虚拟内存地址映射到物理内存地址上</li>
</ul>
<p><img alt="image-20210905151755982" src="image-20210905151755982.png" /></p>
<h3 id="_48">文件描述符</h3>
<ul>
<li>文件描述符表是一个<strong>数组</strong>，为了一个进程能够同时操作多个文件</li>
<li>文件描述符表默认大小：1024</li>
</ul>
<p><img alt="image-20210905160958789" src="image-20210905160958789.png" /></p>
<h3 id="linux-io">Linux 系统 IO 函数</h3>
<h4 id="open-close">open &amp; close</h4>
<ul>
<li>
<p><code>int open(const char *pathname, int flags);</code>，使用<code>man 2 open</code>查看帮助</p>
</li>
<li>
<p>参数</p>
<ul>
<li><code>pathname</code>：要打开的文件路径</li>
<li><code>flags</code>：对文件的操作权限设置还有其他的设置(<code>O_RDONLY,</code>  <code>O_WRONLY,</code>  <code>O_RDWR</code>  这三个设置是互斥的，代表只读，只写，可读可写)</li>
</ul>
</li>
<li>返回值：返回一个新的文件描述符，如果调用失败，返回-1，并设置<code>errno</code>，<code>errno</code>属于Linux系统函数库里面的一个全局变量，记录的是最近的错误号</li>
</ul>
<p>```c
  /<em>
      #include <stdio.h>
      void perror(const char </em>s);作用：打印errno对应的错误描述
          参数s：用户描述，比如hello, 最终输出的内容是  hello:xxx(实际的错误描述)
  */</p>
<p>#include <stdio.h>
  // 系统宏
  #include <sys/types.h>
  #include <sys/stat.h>
  // fopen函数声明头文件
  #include <fcntl.h>
  // close函数声明头文件
  #include <unistd.h></p>
<p>int main() 
  {
      // 打开一个文件
      int fd = open("a.txt", O_RDONLY);</p>
<pre><code>  if(fd == -1) {
      perror("open");
  }
  // 读写操作

  // 关闭
  close(fd);

  return 0;
</code></pre>
<p>}
  ```</p>
<ul>
<li>
<p><code>int open(const char *pathname, int flags, mode_t mode);</code>，使用<code>man 2 open</code>查看帮助</p>
</li>
<li>
<p>参数</p>
<ul>
<li><code>pathname</code>：要创建的文件的路径</li>
<li><code>flags</code>：对文件的操作权限和其他的设置</li>
<li>必选项：<code>O_RDONLY</code>,  <code>O_WRONLY</code>, <code>O_RDWR</code>  这三个之间是互斥的</li>
<li>可选项：<code>O_CREAT</code> 文件不存在，创建新文件</li>
<li><code>flags</code>参数是一个int类型的数据，占4个字节，32位，每一位就是一个标志位，所以用 <code>|</code> 可以保证能够实现多个操作</li>
<li><code>mode</code>：八进制的数，表示创建出的新的文件的操作权限，比如：0775</li>
</ul>
</li>
</ul>
<p>```c
  /<em>
              最终的权限是：mode &amp; ~umask
              0777   -&gt;   111111111
          &amp;   0775   -&gt;   111111101
          ----------------------------
                          111111101
          按位与：0和任何数都为0
          umask的作用就是抹去某些权限, 可以直接在终端输入 umask 查看默认值
  </em>/
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <fcntl.h>
  #include <unistd.h>
  #include <stdio.h></p>
<p>int main() 
  {
      // 创建一个新的文件
      int fd = open("create.txt", O_RDWR | O_CREAT, 0777);</p>
<pre><code>  if(fd == -1) {
      perror("open");
  }

  // 关闭
  close(fd);

  return 0;
</code></pre>
<p>}
  ```</p>
<ul>
<li><code>int close(int fd);</code></li>
</ul>
<h4 id="read-write">read &amp; write</h4>
<ul>
<li><code>ssize_t read(int fd, void *buf, size_t count);</code>，使用<code>man 2 read</code>查看帮助</li>
<li>参数<ul>
<li><code>fd</code>：文件描述符，open得到的，通过这个文件描述符操作某个文件</li>
<li><code>buf</code>：需要读取数据存放的地方，数组的地址（传出参数）</li>
<li><code>count</code>：指定的数组的大小</li>
</ul>
</li>
<li>返回值<ul>
<li>成功</li>
<li><code>&gt; 0</code>: 返回实际的读取到的字节数</li>
<li><code>= 0</code>：文件已经读取完了</li>
<li>失败：-1</li>
</ul>
</li>
<li><code>ssize_t write(int fd, const void *buf, size_t count);</code>，使用<code>man 2 write</code>查看帮助</li>
<li>参数<ul>
<li><code>fd</code>：文件描述符，open得到的，通过这个文件描述符操作某个文件</li>
<li><code>buf</code>：要往磁盘写入的数据</li>
<li><code>count</code>：要写的数据的实际的大小</li>
</ul>
</li>
<li>返回值<ul>
<li>成功：实际写入的字节数</li>
<li>失败：返回-1，并设置<code>errno</code></li>
</ul>
</li>
</ul>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int main() 
{
    // 1.通过open打开english.txt文件
    int srcfd = open(&quot;english.txt&quot;, O_RDONLY);
    if(srcfd == -1) {
        perror(&quot;open&quot;);
        return -1;
    }

    // 2.创建一个新的文件（拷贝文件）
    int destfd = open(&quot;cpy.txt&quot;, O_WRONLY | O_CREAT, 0664);
    if(destfd == -1) {
        perror(&quot;open&quot;);
        return -1;
    }

    // 3.频繁的读写操作
    char buf[1024] = {0};
    int len = 0;
    while((len = read(srcfd, buf, sizeof(buf))) &gt; 0) {
        write(destfd, buf, len);
    }

    // 4.关闭文件
    close(destfd);
    close(srcfd);


    return 0;
}
</code></pre>
<h4 id="lseek">lseek</h4>
<ul>
<li><code>off_t lseek(int fd, off_t offset, int whence);</code>，使用<code>man 2 lseek</code>查看帮助</li>
</ul>
<pre><code class="language-c">/*  
    标准C库的函数
    #include &lt;stdio.h&gt;
    int fseek(FILE *stream, long offset, int whence);

    Linux系统函数
    #include &lt;sys/types.h&gt;
    #include &lt;unistd.h&gt;
    off_t lseek(int fd, off_t offset, int whence);
        参数：
            - fd：文件描述符，通过open得到的，通过这个fd操作某个文件
            - offset：偏移量
            - whence:
                SEEK_SET
                    设置文件指针的偏移量
                SEEK_CUR
                    设置偏移量：当前位置 + 第二个参数offset的值
                SEEK_END
                    设置偏移量：文件大小 + 第二个参数offset的值
        返回值：返回文件指针的位置

    作用：
        1.移动文件指针到文件头
        lseek(fd, 0, SEEK_SET);

        2.获取当前文件指针的位置
        lseek(fd, 0, SEEK_CUR);

        3.获取文件长度
        lseek(fd, 0, SEEK_END);

        4.拓展文件的长度，当前文件10b, 110b, 增加了100个字节
        lseek(fd, 100, SEEK_END)
        注意：需要写一次数据

*/

#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main() 
{
    int fd = open(&quot;hello.txt&quot;, O_RDWR);

    if(fd == -1) {
        perror(&quot;open&quot;);
        return -1;
    }

    // 扩展文件的长度
    int ret = lseek(fd, 100, SEEK_END);
    if(ret == -1) {
        perror(&quot;lseek&quot;);
        return -1;
    }

    // 写入一个空数据，如果缺少，那么会扩展失败
    write(fd, &quot; &quot;, 1);

    // 关闭文件
    close(fd);

    return 0;
}

</code></pre>
<ul>
<li>扩展前</li>
</ul>
<p><img alt="image-20210905182600860" src="image-20210905182600860.png" /></p>
<ul>
<li>扩展后（原先为5个字节，扩展100个字节，然后写入一个字节）</li>
</ul>
<p><img alt="image-20210905182955313" src="image-20210905182955313.png" /></p>
<h4 id="stat-lstat">stat &amp; lstat(获取文件信息及软链接信息)</h4>
<ul>
<li>
<p><code>int stat(const char *pathname, struct stat *statbuf);</code>，使用<code>man 2 stat</code>查看帮助</p>
</li>
<li>
<p><code>int lstat(const char *pathname, struct stat *statbuf);</code>，使用<code>man 2 lstat</code>查看帮助</p>
</li>
<li>
<p>Linux命令：<code>stat</code></p>
</li>
</ul>
<p><img alt="image-20210905184130981" src="image-20210905184130981.png" /></p>
<ul>
<li><code>stat</code>结构体</li>
</ul>
<p><code>c
  struct stat {
      dev_t st_dev; // 文件的设备编号
      ino_t st_ino; // 节点
      mode_t st_mode; // 文件的类型和存取的权限
      nlink_t st_nlink; // 连到该文件的硬连接数目
      uid_t st_uid; // 用户ID
      gid_t st_gid; // 组ID
      dev_t st_rdev; // 设备文件的设备编号
      off_t st_size; // 文件字节数(文件大小)
      blksize_t st_blksize; // 块大小
      blkcnt_t st_blocks; // 块数
      time_t st_atime; // 最后一次访问时间
      time_t st_mtime; // 最后一次修改时间
      time_t st_ctime; // 最后一次改变时间(指属性)
  };</code></p>
<ul>
<li>
<p><code>st_mode</code></p>
<p><img alt="image-20210905184325137" src="image-20210905184325137.png" /></p>
</li>
</ul>
<pre><code class="language-c">/*
    #include &lt;sys/types.h&gt;
    #include &lt;sys/stat.h&gt;
    #include &lt;unistd.h&gt;

    int stat(const char *pathname, struct stat *statbuf);
        作用：获取一个文件相关的一些信息
        参数:
            - pathname：操作的文件的路径
            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息
        返回值：
            成功：返回0
            失败：返回-1 设置errno

    int lstat(const char *pathname, struct stat *statbuf);
        参数:
            - pathname：操作的文件的路径
            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息
        返回值：
            成功：返回0
            失败：返回-1 设置errno

*/

#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main() 
{
    struct stat statbuf;

    int ret = stat(&quot;a.txt&quot;, &amp;statbuf);

    if(ret == -1) {
        perror(&quot;stat&quot;);
        return -1;
    }

    printf(&quot;size: %ld\n&quot;, statbuf.st_size);


    return 0;
}
</code></pre>
<h4 id="ls-l">模拟实现<code>ls -l</code></h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pwd.h&gt;        // for getpwuid()
#include &lt;grp.h&gt;        // for getgrgid()
#include &lt;time.h&gt;       // for ctime()
#include &lt;string.h&gt;     // for strncpy(), strlen()

// 模拟实现 ls -l 指令
// -rw-rw-r-- 1 nowcoder nowcoder 12 12月  3 15:48 a.txt
int main(int argc, char * argv[]) 
{
    // 判断输入的参数是否正确
    if(argc &lt; 2) {
        printf(&quot;%s filename\n&quot;, argv[0]);
        return -1;
    }

    // 通过stat函数获取用户传入的文件的信息
    struct stat st;
    int ret = stat(argv[1], &amp;st);
    if(ret == -1) {
        perror(&quot;stat&quot;);
        return -1;
    }

    // 获取文件类型和文件权限
    char perms[11] = {0};   // 用于保存文件类型和文件权限的字符串

    switch(st.st_mode &amp; S_IFMT) {
        case S_IFLNK:
            perms[0] = 'l';
            break;
        case S_IFDIR:
            perms[0] = 'd';
            break;
        case S_IFREG:
            perms[0] = '-';
            break; 
        case S_IFBLK:
            perms[0] = 'b';
            break; 
        case S_IFCHR:
            perms[0] = 'c';
            break; 
        case S_IFSOCK:
            perms[0] = 's';
            break;
        case S_IFIFO:
            perms[0] = 'p';
            break;
        default:
            perms[0] = '?';
            break;
    }

    // 判断文件的访问权限

    // 文件所有者
    perms[1] = (st.st_mode &amp; S_IRUSR) ? 'r' : '-';
    perms[2] = (st.st_mode &amp; S_IWUSR) ? 'w' : '-';
    perms[3] = (st.st_mode &amp; S_IXUSR) ? 'x' : '-';

    // 文件所在组
    perms[4] = (st.st_mode &amp; S_IRGRP) ? 'r' : '-';
    perms[5] = (st.st_mode &amp; S_IWGRP) ? 'w' : '-';
    perms[6] = (st.st_mode &amp; S_IXGRP) ? 'x' : '-';

    // 其他人
    perms[7] = (st.st_mode &amp; S_IROTH) ? 'r' : '-';
    perms[8] = (st.st_mode &amp; S_IWOTH) ? 'w' : '-';
    perms[9] = (st.st_mode &amp; S_IXOTH) ? 'x' : '-';

    // 硬连接数
    int linkNum = st.st_nlink;

    // 文件所有者
    char* fileUser = getpwuid(st.st_uid)-&gt;pw_name;

    // 文件所在组
    char* fileGrp = getgrgid(st.st_gid)-&gt;gr_name;

    // 文件大小
    long int fileSize = st.st_size;

    // 获取修改的时间
    char* time = ctime(&amp;st.st_mtime);

    char mtime[512] = {0};
    strncpy(mtime, time, strlen(time) - 1);

    char buf[1024];
    sprintf(buf, &quot;%s %d %s %s %ld %s %s&quot;, perms, linkNum, fileUser, fileGrp, fileSize, mtime, argv[1]);

    printf(&quot;%s\n&quot;, buf);

    return 0;
}
</code></pre>
<h3 id="_49">文件属性操作函数</h3>
<h4 id="access">access</h4>
<ul>
<li><code>int access(const char *pathname, int mode);</code></li>
</ul>
<pre><code class="language-c">/*
    #include &lt;unistd.h&gt;
    int access(const char *pathname, int mode);
        作用：判断某个文件是否有某个权限，或者判断文件是否存在
        参数：
            - pathname: 判断的文件路径
            - mode:
                R_OK: 判断是否有读权限
                W_OK: 判断是否有写权限
                X_OK: 判断是否有执行权限
                F_OK: 判断文件是否存在
        返回值：成功返回0， 失败返回-1
*/

#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main() 
{
    int ret = access(&quot;a.txt&quot;, F_OK);
    if(ret == -1) {
        perror(&quot;access&quot;);
    }

    printf(&quot;文件存在！！!\n&quot;);

    return 0;
}
</code></pre>
<h4 id="chmod-chown">chmod &amp; chown</h4>
<ul>
<li><code>int chmod(const char *filename, int mode);</code></li>
</ul>
<pre><code class="language-c">/*
    #include &lt;sys/stat.h&gt;
    int chmod(const char *pathname, mode_t mode);
        修改文件的权限
        参数：
            - pathname: 需要修改的文件的路径
            - mode:需要修改的权限值，八进制的数
        返回值：成功返回0，失败返回-1

*/
#include &lt;sys/stat.h&gt;
#include &lt;stdio.h&gt;
int main() 
{
    int ret = chmod(&quot;a.txt&quot;, 0777);

    if(ret == -1) {
        perror(&quot;chmod&quot;);
        return -1;
    }

    return 0;
}
</code></pre>
<ul>
<li><code>int chown(const char *path, uid_t owner, gid_t group);</code></li>
<li>修改文件所有者</li>
<li>可使用<code>vim /etc/passwd</code>查看有哪些用户</li>
<li>可使用<code>vim /etc/group</code>查看有哪些组</li>
</ul>
<h4 id="truncate">truncate</h4>
<ul>
<li><code>int truncate(const char *path, off_t length);</code></li>
</ul>
<pre><code class="language-c">/*
    #include &lt;unistd.h&gt;
    #include &lt;sys/types.h&gt;
    int truncate(const char *path, off_t length);
        作用：缩减或者扩展文件的尺寸至指定的大小
        参数：
            - path: 需要修改的文件的路径
            - length: 需要最终文件变成的大小
        返回值：
            成功返回0， 失败返回-1
*/

#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;

int main() 
{
    int ret = truncate(&quot;b.txt&quot;, 5);

    if(ret == -1) {
        perror(&quot;truncate&quot;);
        return -1;
    }

    return 0;
}
</code></pre>
<h3 id="_50">目录操作函数</h3>
<h4 id="mkdir">mkdir</h4>
<ul>
<li><code>int mkdir(const char *pathname, mode_t mode);</code></li>
</ul>
<pre><code class="language-c">/*
    #include &lt;sys/stat.h&gt;
    #include &lt;sys/types.h&gt;
    int mkdir(const char *pathname, mode_t mode);
        作用：创建一个目录
        参数：
            pathname: 创建的目录的路径
            mode: 权限，八进制的数
        返回值：
            成功返回0， 失败返回-1
*/

#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;

int main() 
{
    int ret = mkdir(&quot;aaa&quot;, 0777);

    if(ret == -1) {
        perror(&quot;mkdir&quot;);
        return -1;
    }

    return 0;
}
</code></pre>
<h4 id="rename">rename</h4>
<ul>
<li><code>int rename(const char *oldpath, const char *newpath);</code></li>
</ul>
<pre><code class="language-c">/*
    #include &lt;stdio.h&gt;
    int rename(const char *oldpath, const char *newpath);

*/
#include &lt;stdio.h&gt;

int main() 
{
    int ret = rename(&quot;aaa&quot;, &quot;bbb&quot;);

    if(ret == -1) {
        perror(&quot;rename&quot;);
        return -1;
    }

    return 0;
}
</code></pre>
<h4 id="chdir-getcwd">chdir &amp; getcwd</h4>
<ul>
<li>
<p><code>int chdir(const char *path);</code></p>
</li>
<li>
<p><code>char *getcwd(char *buf, size_t size);</code></p>
</li>
</ul>
<pre><code class="language-c">/*

    #include &lt;unistd.h&gt;
    int chdir(const char *path);
        作用：修改进程的工作目录
            比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder
        参数：
            path : 需要修改的工作目录

    #include &lt;unistd.h&gt;
    char *getcwd(char *buf, size_t size);
        作用：获取当前工作目录
        参数：
            - buf : 存储的路径，指向的是一个数组（传出参数）
            - size: 数组的大小
        返回值：
            返回的指向的一块内存，这个数据就是第一个参数

*/
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;

int main() 
{
    // 获取当前的工作目录
    char buf[128];
    getcwd(buf, sizeof(buf));
    printf(&quot;当前的工作目录是：%s\n&quot;, buf);

    // 修改工作目录
    int ret = chdir(&quot;/home/u/Desktop/Linux/test&quot;);
    if(ret == -1) {
        perror(&quot;chdir&quot;);
        return -1;
    } 

    // 创建一个新的文件
    int fd = open(&quot;chdir.txt&quot;, O_CREAT | O_RDWR, 0664);
    if(fd == -1) {
        perror(&quot;open&quot;);
        return -1;
    }

    close(fd);

    // 获取当前的工作目录
    char buf1[128];
    getcwd(buf1, sizeof(buf1));
    printf(&quot;当前的工作目录是：%s\n&quot;, buf1);

    return 0;
}
</code></pre>
<h3 id="_51">目录遍历函数</h3>
<ul>
<li>
<p>打开一个目录：<code>DIR *opendir(const char *name);</code></p>
</li>
<li>
<p>读取目录中的数据：<code>struct dirent *readdir(DIR *dirp);</code></p>
</li>
<li>
<p>关闭目录：<code>int closedir(DIR *dirp);</code></p>
</li>
<li>
<p><code>dirent</code> 结构体和 <code>d_type</code></p>
</li>
</ul>
<p><code>c
  struct dirent
  {
      // 此目录进入点的inode
      ino_t d_ino; 
      // 目录文件开头至此目录进入点的位移
      off_t d_off; 
      // d_name 的长度, 不包含NULL字符
      unsigned short int d_reclen; 
      // d_name 所指的文件类型
      unsigned char d_type; 
      // 文件名
      char d_name[256];
  };</code></p>
<ul>
<li>
<p><code>d_type</code></p>
<p><img alt="image-20210908203416289" src="image-20210908203416289.png" /></p>
</li>
<li>
<p><strong>读取文件夹文件数目</strong>实例</p>
</li>
</ul>
<p>```c
  /<em>
      // 打开一个目录
      #include <sys/types.h>
      #include <dirent.h>
      DIR </em>opendir(const char *name);
          参数：
              - name: 需要打开的目录的名称
          返回值：
              DIR * 类型，理解为目录流
              错误返回NULL</p>
<pre><code>  // 读取目录中的数据
  #include &lt;dirent.h&gt;
  struct dirent *readdir(DIR *dirp);
      - 参数：dirp是opendir返回的结果
      - 返回值：
          struct dirent，代表读取到的文件的信息
          读取到了末尾或者失败了，返回NULL

  // 关闭目录
  #include &lt;sys/types.h&gt;
  #include &lt;dirent.h&gt;
  int closedir(DIR *dirp);
</code></pre>
<p>*/
  #include <sys/types.h>
  #include <dirent.h>
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h></p>
<p>int getFileNum(const char * path);</p>
<p>// 读取某个目录下所有的普通文件的个数
  int main(int argc, char * argv[]) 
  {
      if(argc &lt; 2) {
          printf("%s path\n", argv[0]);
          return -1;
      }</p>
<pre><code>  int num = getFileNum(argv[1]);

  printf("普通文件的个数为：%d\n", num);

  return 0;
</code></pre>
<p>}</p>
<p>// 用于获取目录下所有普通文件的个数
  int getFileNum(const char * path) {</p>
<pre><code>  // 1.打开目录
  DIR * dir = opendir(path);

  if(dir == NULL) {
      perror("opendir");
      exit(0);
  }

  struct dirent *ptr;

  // 记录普通文件的个数
  int total = 0;

  while((ptr = readdir(dir)) != NULL) {

      // 获取名称
      char * dname = ptr-&gt;d_name;

      // 忽略掉. 和..
      if(strcmp(dname, ".") == 0 || strcmp(dname, "..") == 0) {
          continue;
      }

      // 判断是否是普通文件还是目录
      if(ptr-&gt;d_type == DT_DIR) {
          // 目录,需要继续读取这个目录
          char newpath[256];
          sprintf(newpath, "%s/%s", path, dname);
          total += getFileNum(newpath);
      }

      if(ptr-&gt;d_type == DT_REG) {
          // 普通文件
          total++;
      }
  }

  // 关闭目录
  closedir(dir);

  return total;
</code></pre>
<p>}
  ```</p>
<h3 id="dupdup2">文件描述符之<code>dup</code>、<code>dup2</code></h3>
<h4 id="dup">dup</h4>
<ul>
<li><code>int dup(int oldfd);</code></li>
<li>复制文件描述符</li>
</ul>
<pre><code class="language-c">/*
    #include &lt;unistd.h&gt;
    int dup(int oldfd);
        作用：复制一个新的文件描述符
        fd=3, int fd1 = dup(fd),
        fd指向的是a.txt, fd1也是指向a.txt
        从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符


*/

#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;

int main() 
{
    int fd = open(&quot;a.txt&quot;, O_RDWR | O_CREAT, 0664);

    int fd1 = dup(fd);

    if(fd1 == -1) {
        perror(&quot;dup&quot;);
        return -1;
    }

    printf(&quot;fd : %d , fd1 : %d\n&quot;, fd, fd1);

    close(fd);

    char * str = &quot;hello,world&quot;;
    int ret = write(fd1, str, strlen(str));
    if(ret == -1) {
        perror(&quot;write&quot;);
        return -1;
    }

    close(fd1);

    return 0;
}
</code></pre>
<h4 id="dup2">dup2</h4>
<ul>
<li><code>int dup2(int oldfd, int newfd);</code></li>
<li>重定向文件描述符</li>
</ul>
<pre><code class="language-c">/*
    #include &lt;unistd.h&gt;
    int dup2(int oldfd, int newfd);
        作用：重定向文件描述符
        oldfd 指向 a.txt, newfd 指向 b.txt
        调用函数成功后：newfd 和 b.txt 做close, newfd 指向了 a.txt
        oldfd 必须是一个有效的文件描述符
        oldfd和newfd值相同，相当于什么都没有做
*/
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;

int main() 
{
    int fd = open(&quot;1.txt&quot;, O_RDWR | O_CREAT, 0664);
    if(fd == -1) {
        perror(&quot;open&quot;);
        return -1;
    }

    int fd1 = open(&quot;2.txt&quot;, O_RDWR | O_CREAT, 0664);
    if(fd1 == -1) {
        perror(&quot;open&quot;);
        return -1;
    }

    printf(&quot;fd : %d, fd1 : %d\n&quot;, fd, fd1);

    int fd2 = dup2(fd, fd1);
    if(fd2 == -1) {
        perror(&quot;dup2&quot;);
        return -1;
    }

    // 通过fd1去写数据，实际操作的是1.txt，而不是2.txt
    char * str = &quot;hello, dup2&quot;;
    int len = write(fd1, str, strlen(str));

    if(len == -1) {
        perror(&quot;write&quot;);
        return -1;
    }

    printf(&quot;fd : %d, fd1 : %d, fd2 : %d\n&quot;, fd, fd1, fd2);

    close(fd);
    close(fd1);

    return 0;
}
</code></pre>
<h3 id="fcntl">fcntl 函数</h3>
<ul>
<li><code>int fcntl(int fd, int cmd, ... /* arg */ );</code></li>
<li><strong>复制文件描述符</strong>和<strong>设置/获取文件的状态标志</strong></li>
</ul>
<pre><code class="language-c">/*

    #include &lt;unistd.h&gt;
    #include &lt;fcntl.h&gt;

    int fcntl(int fd, int cmd, ...);
    参数：
        fd : 表示需要操作的文件描述符
        cmd: 表示对文件描述符进行如何操作
            - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）
                int ret = fcntl(fd, F_DUPFD);

            - F_GETFL : 获取指定的文件描述符文件状态flag
              获取的flag和我们通过open函数传递的flag是一个东西。

            - F_SETFL : 设置文件描述符文件状态flag
              必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改
              可选性：O_APPEND, O_NONBLOCK
                O_APPEND 表示追加数据
                NONBLOK 设置成非阻塞

        阻塞和非阻塞：描述的是函数调用的行为。
*/

#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() 
{
    // 1.复制文件描述符
    // int fd = open(&quot;1.txt&quot;, O_RDONLY);
    // int ret = fcntl(fd, F_DUPFD);

    // 2.修改或者获取文件状态flag
    int fd = open(&quot;1.txt&quot;, O_RDWR);
    if(fd == -1) {
        perror(&quot;open&quot;);
        return -1;
    }

    // 获取文件描述符状态flag
    int flag = fcntl(fd, F_GETFL);
    if(flag == -1) {
        perror(&quot;fcntl&quot;);
        return -1;
    }
    flag |= O_APPEND;   // flag = flag | O_APPEND

    // 修改文件描述符状态的flag，给flag加入O_APPEND这个标记
    int ret = fcntl(fd, F_SETFL, flag);
    if(ret == -1) {
        perror(&quot;fcntl&quot;);
        return -1;
    }

    char * str = &quot;nihao&quot;;
    write(fd, str, strlen(str));

    close(fd);

    return 0;
}
</code></pre>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
