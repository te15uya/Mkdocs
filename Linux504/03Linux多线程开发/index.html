<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>线程基础 - Tetsuya's MkDocs</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u7ebf\u7a0b\u57fa\u7840";
        var mkdocs_page_input_path = "Linux504\\03Linux\u591a\u7ebf\u7a0b\u5f00\u53d1.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Tetsuya's MkDocs
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Linux504</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../01Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/">1.Linux系统编程入门</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Tetsuya's MkDocs</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
      <li>线程基础</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1">线程基础</h1>
<h2 id="_2">说明</h2>
<p>本部分笔记及源码出自<code>slide/03Linux多线程开发/01 线程基础</code></p>
<h2 id="_3">线程概述</h2>
<h3 id="_4">基本概念</h3>
<ul>
<li>与<code>进程（process）</code>类似，<code>线程（thread）</code>是允许应用程序<strong>并发执行多个任务</strong>的一种机制</li>
<li>一个进程可以包含多个线程</li>
<li>同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程）</li>
<li><strong>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位</strong></li>
<li>线程是轻量级的进程（<code>LWP：Light Weight Process</code>），在 Linux 环境下线程的本质仍是进程</li>
<li>查看指定进程的 <code>LWP</code> 号：<code>ps –Lf pid</code>，其中<code>pid</code>可以由<code>ps aux</code>得到</li>
<li>一般情况下，<code>main函数</code>所在的线程我们称之为<code>主线程（main线程）</code>，其余创建的线程称为<code>子线程</code></li>
<li>程序中默认只有一个进程，<code>fork()</code>函数调用，2进程（父子进程）</li>
<li>程序中默认只有一个线程，<code>pthread_create()</code>函数调用，2个线程（主线程和子线程）</li>
</ul>
<h3 id="_5">线程和进程区别</h3>
<ul>
<li><strong>进程间的信息难以共享</strong>。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换</li>
<li>调用 <code>fork()</code> 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 <code>fork()</code> 调用在时间上的开销依然不菲</li>
<li>线程之间能够方便、快速地共享信息。只需<strong>将数据复制到共享（全局或堆）变量</strong>中即可</li>
<li>创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表</li>
</ul>
<h3 id="_6">线程之间共享和非共享资源</h3>
<h4 id="_7">共享资源</h4>
<ul>
<li>进程 ID 和父进程 ID</li>
<li>进程组 ID 和会话 ID</li>
<li>用户 ID 和 用户组 ID</li>
<li>文件描述符表</li>
<li>信号处置</li>
<li>文件系统的相关信息：文件权限掩码（<code>umask</code>）、当前工作目录</li>
<li>虚拟地址空间（<strong>除栈、.text</strong>）</li>
</ul>
<h4 id="_8">非共享资源</h4>
<ul>
<li>线程 ID</li>
<li>信号掩码</li>
<li>线程特有数据</li>
<li>error 变量</li>
<li>实时调度策略和优先级</li>
<li>栈，本地变量和函数的调用链接信息</li>
</ul>
<h3 id="nptl">NPTL</h3>
<ul>
<li>当 Linux 最初开发时，在内核中并不能真正支持线程。但是它的确可以通过 <code>clone()</code> 系统调用将进程作为可调度的实体。这个调用创建了调用进程（calling process）的一个拷贝，这个拷贝与调用进程共享相同的地址空间。<code>LinuxThreads</code> 项目使用这个调用来完成在用户空间模拟对线程的支持。不幸的是，这种方法有一些缺点，尤其是在信号处理、调度和进程间同步等方面都存在问题。另外，这个线程模型也不符合 <code>POSIX</code> 的要求</li>
<li>要改进 <code>LinuxThreads</code>，需要内核的支持，并且重写线程库。有两个相互竞争的项目开始来满足这些要求</li>
<li>一个包括 IBM 的开发人员的团队开展了 <code>NGPT（Next-Generation POSIX Threads）</code>项目</li>
<li>同时，Red Hat 的一些开发人员开展了 <code>NPTL</code> 项目</li>
<li>
<p><code>NGPT</code> 在 2003 年中期被放弃了，把这个领域完全留给了 <code>NPTL</code></p>
</li>
<li>
<p><code>NPTL</code>，或称为 <code>Native POSIX Thread Library</code>，是 Linux 线程的一个新实现，它克服了 <code>LinuxThreads</code>的缺点，同时也符合 <code>POSIX</code> 的需求。与 <code>LinuxThreads</code> 相比，它在性能和稳定性方面都提供了重大的改进</p>
</li>
<li>
<p>查看当前 <code>pthread</code> 库版本：<code>getconf GNU_LIBPTHREAD_VERSION</code></p>
</li>
</ul>
<p><img alt="image-20211024092845797" src="image-20211024092845797.png" /></p>
<h3 id="_9">注意</h3>
<ul>
<li>由于<code>pthread</code>属于第三方库，所以在编译时需要加上参数<code>-pthread</code>或<code>-lpthread</code>即指定包路径，如果不加报以下错误（执行程序为线程创建）</li>
</ul>
<p><img alt="image-20211024094053228" src="image-20211024094053228.png" /></p>
<h2 id="_10">线程操作函数</h2>
<ul>
<li>
<p>获取当前的线程的线程ID：<code>pthread_t pthread_self(void);</code></p>
</li>
<li>
<p>比较两个线程ID是否相等：<code>int pthread_equal(pthread_t t1, pthread_t t2);</code></p>
</li>
</ul>
<blockquote>
<p>不同的操作系统，<code>pthread_t</code>类型的实现不一样，有的是无符号的长整型，有的是使用结构体去实现的</p>
</blockquote>
<ul>
<li>
<p>线程创建：<code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</code></p>
</li>
<li>
<p>线程终止：<code>void pthread_exit(void *retval);</code></p>
</li>
</ul>
<h2 id="_11">线程创建</h2>
<ul>
<li><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</code></li>
<li>通过<code>man 3 pthread_create</code>查看帮助</li>
<li>功能：创建一个子线程</li>
<li>参数<ul>
<li><code>thread</code>：传出参数，线程创建成功后，子线程的线程ID被写到该变量中</li>
<li><code>attr</code> : 设置线程的属性，一般使用默认值，NULL</li>
<li><code>start_routine</code> : 函数指针，这个函数是子线程需要处理的逻辑代码</li>
<li><code>arg</code> : 给第三个参数(<code>start_routine</code>)使用，传参</li>
</ul>
</li>
<li>返回值<ul>
<li>成功：0</li>
<li>失败：返回错误号。这个错误号和之前<code>errno</code>不太一样。获取错误号的信息：  <code>char * strerror(int errnum);</code></li>
</ul>
</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

void* myWork(void* arg) {
    printf(&quot;child thread...\n&quot;);
    printf(&quot;num = %d\n&quot;, *(int*)arg);

    return NULL;
}

int main()
{
    // 创建子线程
    pthread_t tid;
    int num = 10;
    int ret = pthread_create(&amp;tid, NULL, myWork, (void*)&amp;num);
    if (ret != 0) {
        char * errstr = strerror(ret);
        printf(&quot;error : %s\n&quot;, errstr);
    }

    for (int i = 0; i &lt; 5; i++) {
        printf(&quot;%d\n&quot;, i);
    }

    // 防止子线程没有抢占到CPU且此时主线程已经执行完并退出
    sleep(1);
    return 0;
}
</code></pre>
<p><img alt="image-20211024094256740" src="image-20211024094256740.png" /></p>
<h2 id="_12">线程终止</h2>
<ul>
<li><code>void pthread_exit(void *retval);</code></li>
<li>通过<code>man 3 pthread_exit</code>查看帮助</li>
<li>功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程</li>
<li>参数：<code>retval</code>，需要传递一个指针，作为一个返回值，可以在<code>pthread_join()</code>中获取到</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

void* myWork(void* arg) {
    printf(&quot;child thread...\n&quot;);
    printf(&quot;num = %d\n&quot;, *(int*)arg);
    printf(&quot;child thread id : %ld\n&quot;, pthread_self());

    return NULL;
}

int main()
{
    // 创建子线程
    pthread_t tid;
    int num = 10;
    int ret = pthread_create(&amp;tid, NULL, myWork, (void*)&amp;num);
    if (ret != 0) {
        char * errstr = strerror(ret);
        printf(&quot;error : %s\n&quot;, errstr);
    }
    printf(&quot;tid : %ld, main thread id : %ld\n&quot;, tid ,pthread_self());

    for (int i = 0; i &lt; 5; i++) {
        printf(&quot;%d\n&quot;, i);
    }

    // 让主线程退出，当主线程退出时，不会影响其他正常运行的线程
    pthread_exit(NULL);
    // 下面程序已经不能被执行
    printf(&quot;test message\n&quot;);

    return 0;
}
</code></pre>
<p><img alt="image-20211024100756859" src="image-20211024100756859.png" /></p>
<h2 id="_13">线程连接</h2>
<ul>
<li><code>int pthread_join(pthread_t thread, void **retval);</code></li>
<li>通过<code>man 3 pthread_join</code>查看帮助</li>
<li>功能：和一个已经终止的线程进行连接。回收子线程的资源，这个函数是阻塞函数，调用一次只能回收一个子线程，一般在主线程中使用</li>
<li>参数<ul>
<li><code>thread</code>：需要回收的子线程的ID</li>
<li><code>retval</code>：接收子线程退出时的返回值</li>
</ul>
</li>
<li>返回值<ul>
<li>成功：0</li>
<li>失败：返回错误号。这个错误号和之前<code>errno</code>不太一样。获取错误号的信息：  <code>char * strerror(int errnum);</code></li>
</ul>
</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

int val = 10;

void* myWork(void* arg) {
    printf(&quot;child thread...\n&quot;);
    printf(&quot;num = %d\n&quot;, *(int*)arg);
    printf(&quot;child thread id : %ld\n&quot;, pthread_self());
    val++;

    pthread_exit((void*)&amp;val);     // 等价于return (void*)&amp;val;
}

int main()
{
    printf(&quot;init val : %d\n&quot;, val);
    // 创建子线程
    pthread_t tid;
    int num = 10;
    int ret = pthread_create(&amp;tid, NULL, myWork, (void*)&amp;num);
    if (ret != 0) {
        char * errstr = strerror(ret);
        printf(&quot;error : %s\n&quot;, errstr);
    }
    printf(&quot;tid : %ld, main thread id : %ld\n&quot;, tid ,pthread_self());

    for (int i = 0; i &lt; 5; i++) {
        printf(&quot;%d\n&quot;, i);
    }

    // 主线程调用pthread_join()回收子线程的资源
    int * thread_retval;
    ret = pthread_join(tid, (void **)&amp;thread_retval);

    if(ret != 0) {
        char * errstr = strerror(ret);
        printf(&quot;error : %s\n&quot;, errstr);
    }
    printf(&quot;exit data : %d\n&quot;, *thread_retval);
    printf(&quot;回收子线程资源成功！\n&quot;);

    // 让主线程退出，当主线程退出时，不会影响其他正常运行的线程
    pthread_exit(NULL);
    // 下面程序已经不能被执行
    printf(&quot;test message\n&quot;);

    return 0;
}
</code></pre>
<p><img alt="image-20211024102827228" src="image-20211024102827228.png" /></p>
<h2 id="_14">线程分离</h2>
<ul>
<li><code>int pthread_detach(pthread_t thread);</code></li>
<li>通过<code>man 3 pthread_detach</code>查看帮助</li>
<li>功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统<ul>
<li>不能多次分离，会产生不可预料的行为</li>
<li>不能去连接一个已经分离的线程，会报错</li>
</ul>
</li>
<li>参数：需要分离的线程的ID</li>
<li>返回值<ul>
<li>成功：0</li>
<li>失败：返回错误号。这个错误号和之前<code>errno</code>不太一样。获取错误号的信息：  <code>char * strerror(int errnum);</code></li>
</ul>
</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

void* myWork(void * arg) {
    printf(&quot;chid thread id : %ld\n&quot;, pthread_self());
    return NULL;
}

int main() 
{
    // 创建一个子线程
    pthread_t tid;
    int ret = pthread_create(&amp;tid, NULL, myWork, NULL);
    if(ret != 0) {
        char * errstr = strerror(ret);
        printf(&quot;error1 : %s\n&quot;, errstr);
    }

    // 输出主线程和子线程的id
    printf(&quot;tid : %ld, main thread id : %ld\n&quot;, tid, pthread_self());

    // 设置子线程分离,子线程分离后，子线程结束时对应的资源就不需要主线程释放
    ret = pthread_detach(tid);
    if(ret != 0) {
        char * errstr = strerror(ret);
        printf(&quot;error2 : %s\n&quot;, errstr);
    }

    // 设置分离后，对分离的子线程进行连接 pthread_join()
    // ret = pthread_join(tid, NULL);
    // if(ret != 0) {
    //     char * errstr = strerror(ret);
    //     printf(&quot;error3 : %s\n&quot;, errstr);
    // }

    pthread_exit(NULL);

    return 0;
}
</code></pre>
<p><img alt="image-20211024112014474" src="image-20211024112014474.png" /></p>
<h2 id="_15">线程取消</h2>
<ul>
<li><code>int pthread_cancel(pthread_t thread);</code></li>
<li>通过<code>man 3 pthread_cancel</code>查看帮助</li>
<li>功能：取消线程（让线程终止）。取消某个线程，可以终止某个线程的运行， 但是并不是立马终止，而是当子线程执行到一个<strong>取消点</strong>，线程才会终止</li>
<li><strong>取消点</strong>：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区切换的位置，可以通过<code>man pthreads</code>查看取消点</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

void* myWork(void * arg) {
    printf(&quot;chid thread id : %ld\n&quot;, pthread_self());
    for (int i = 0; i &lt; 20; i++) {
        printf(&quot;child: %d\n&quot;, i);
    }
    return NULL;
}

int main() 
{
    // 创建一个子线程
    pthread_t tid;
    int ret = pthread_create(&amp;tid, NULL, myWork, NULL);
    if(ret != 0) {
        char * errstr = strerror(ret);
        printf(&quot;error1 : %s\n&quot;, errstr);
    }

    // 线程取消
    pthread_cancel(tid);
    for (int i = 0; i &lt; 20; i++) {
        printf(&quot;main: %d\n&quot;, i);
    }

    // 输出主线程和子线程的id
    printf(&quot;tid : %ld, main thread id : %ld\n&quot;, tid, pthread_self());

    pthread_exit(NULL);

    return 0;
}
</code></pre>
<ul>
<li>
<p>以上代码在不同机器可能无法触发线程取消，每次执行结果也不一定相同=&gt;==猜测由于速度过快==</p>
</li>
<li>
<p>虚拟机</p>
<p><img alt="image-20211024141255941" src="image-20211024141255941.png" /></p>
</li>
<li>
<p>实体机</p>
<p><img alt="image-20211024140914892" src="image-20211024140914892.png" /></p>
</li>
</ul>
<h2 id="_16">线程属性</h2>
<h3 id="api">常用API</h3>
<ul>
<li>线程属性类型：<code>pthread_attr_t</code></li>
<li>初始化线程属性变量：<code>int pthread_attr_init(pthread_attr_t *attr);</code></li>
<li>释放线程属性的资源：<code>int pthread_attr_destroy(pthread_attr_t *attr);</code></li>
<li>获取线程分离的状态属性：<code>int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);</code></li>
<li>设置线程分离的状态属性：<code>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code></li>
</ul>
<h3 id="_17">设置步骤</h3>
<ol>
<li>创建一个线程属性变量</li>
<li>初始化属性变量</li>
<li>设置属性</li>
<li>释放线程属性资源</li>
</ol>
<h3 id="_18">实例：通过设置线程属性实现线程分离</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

void* myWork(void * arg) {
    printf(&quot;chid thread id : %ld\n&quot;, pthread_self());
    for (int i = 0; i &lt; 5; i++) {
        printf(&quot;child: %d\n&quot;, i);
    }
    return NULL;
}

int main() 
{
    // 1. 创建一个线程属性变量
    pthread_attr_t attr;
    // 2. 初始化属性变量
    pthread_attr_init(&amp;attr);
    // 3. 设置属性-线程分离
    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);

    // 创建一个子线程
    pthread_t tid;
    int ret = pthread_create(&amp;tid, NULL, myWork, NULL);
    if(ret != 0) {
        char * errstr = strerror(ret);
        printf(&quot;error1 : %s\n&quot;, errstr);
    }

    // 获取线程的栈的大小
    size_t size;
    pthread_attr_getstacksize(&amp;attr, &amp;size);
    printf(&quot;thread stack size : %ld\n&quot;, size);

    // 输出主线程和子线程的id
    printf(&quot;tid : %ld, main thread id : %ld\n&quot;, tid, pthread_self());
    // 4. 释放线程属性资源
    pthread_attr_destroy(&amp;attr);

    pthread_exit(NULL);

    return 0;
}
</code></pre>
<p><img alt="image-20211024143206510" src="image-20211024143206510.png" /></p>
<h1 id="_19">线程同步</h1>
<h2 id="_20">说明</h2>
<p>本部分笔记及源码出自<code>slide/03Linux多线程开发/02 线程同步</code></p>
<h2 id="_21">==疑问==</h2>
<p>什么时候加锁合适？不同时机加锁可能会导致不一样的结果</p>
<h2 id="_22">出现的原因</h2>
<ul>
<li>假设我有100张票，有三个窗口同时在售卖，那么</li>
<li>如果<code>ticket</code>为局部变量，那么每个窗口都是从100开始售卖=&gt;执行<code>test1()</code></li>
<li>如果<code>ticket</code>为全局变量，那么不同窗口可能因为抢占资源而同时开始售卖，导致出现同时在卖同一张票（可能出现负数票）=&gt;执行<code>test2()</code></li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;

void* selltickets1(void* arg) {
    int tickets = 10;
    while (tickets &gt; 0) {
        printf(&quot;线程%ld 正在售卖第%d张票\n&quot;, pthread_self(), tickets);
        tickets--;
    }

    return NULL;
}

void test1() {
    // 创建三个线程
    pthread_t tid1;
    pthread_t tid2;
    pthread_t tid3;
    pthread_create(&amp;tid1, NULL, selltickets1, NULL);
    pthread_create(&amp;tid2, NULL, selltickets1, NULL);
    pthread_create(&amp;tid3, NULL, selltickets1, NULL);
    // 线程连接，回收子线程的资源，阻塞
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);
    pthread_join(tid3, NULL);
}

int total_tickets = 10;

void* selltickets2(void* arg) {
    while (total_tickets &gt; 0) {
        printf(&quot;线程%ld 正在售卖第%d张票\n&quot;, pthread_self(), total_tickets);
        total_tickets--;
    }

    return NULL;
}

void test2() {
    // 创建三个线程
    pthread_t tid1;
    pthread_t tid2;
    pthread_t tid3;
    pthread_create(&amp;tid1, NULL, selltickets2, NULL);
    pthread_create(&amp;tid2, NULL, selltickets2, NULL);
    pthread_create(&amp;tid3, NULL, selltickets2, NULL);
    // 线程连接，回收子线程的资源，阻塞
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);
    pthread_join(tid3, NULL);
}


int main()
{
    test2();
    pthread_exit(NULL);     // 退出main进程
    return 0;
}
</code></pre>
<ul>
<li>执行<code>test1</code></li>
</ul>
<p><img alt="image-20211024145941102" src="image-20211024145941102.png" /></p>
<ul>
<li>执行<code>test2</code></li>
</ul>
<p><img alt="image-20211024145916760" src="image-20211024145916760.png" /></p>
<h2 id="_23">线程同步概念</h2>
<ul>
<li>线程的主要优势在于，<strong>能够通过全局变量来共享信息</strong>。不过，这种便捷的共享是有代价的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量</li>
<li><code>临界区</code>是指访问某一共享资源的代码片段，并且这段代码的执行应为<code>原子操作</code>，也就是同时访问同一共享资源的其他线程不应终端该片段的执行</li>
<li><code>线程同步</code>：即<strong>当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态</strong></li>
</ul>
<h2 id="_24">互斥量/互斥锁</h2>
<h3 id="_25">基本概念</h3>
<ul>
<li>
<p>为避免线程更新共享变量时出现问题，可以使用<code>互斥量（mutex 是 mutual exclusion的缩写）</code>来确保同时仅有一个线程可以访问某项共享资源。使用<strong>互斥量能保证对任意共享资源的原子访问</strong></p>
</li>
<li>
<p>互斥量有两种状态：<code>已锁定（locked）</code>和<code>未锁定（unlocked）</code>。任何时候，<strong>至多只有一个线程可以锁定该互斥量</strong>。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法</p>
</li>
<li>
<p>一旦线程锁定互斥量，随即成为该互斥量的所有者，<strong>只有所有者才能给互斥量解锁</strong>。一般情况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议</p>
</li>
<li>
<p>针对共享资源锁定互斥量</p>
</li>
<li>访问共享资源</li>
<li>
<p>对互斥量解锁</p>
</li>
<li>
<p>如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域，如下</p>
</li>
</ul>
<p><img alt="image-20211024153557069" src="image-20211024153557069.png" /></p>
<h3 id="_26">互斥量相关操作函数</h3>
<ul>
<li>互斥量的类型：<code>pthread_mutex_t</code></li>
<li>初始化互斥量：<code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></li>
<li>参数<ul>
<li><code>mutex</code> ： 需要初始化的互斥量变量</li>
<li><code>attr</code> ： 互斥量相关的属性，设置为NULL，由内核指定</li>
</ul>
</li>
<li>
<p><code>restrict</code> : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作</p>
</li>
<li>
<p>释放互斥量的资源：<code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></p>
</li>
<li>加锁：<code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></li>
<li>尝试加锁：<code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></li>
<li>解锁：<code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></li>
</ul>
<h3 id="_27">实例：互斥锁实现进程同步售票</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;

// 全局变量创建互斥量，保证所有线程都能访问
pthread_mutex_t mutex;

int total_tickets = 100;

void* selltickets(void* arg) {
    while (1) {
        // 加锁
        pthread_mutex_lock(&amp;mutex);
        if (total_tickets &gt; 0) {
            // 访问共享变量
            printf(&quot;线程%ld 正在售卖第%d张票\n&quot;, pthread_self(), total_tickets);
            total_tickets--;
        } else {
            // 解锁
            pthread_mutex_unlock(&amp;mutex);
            break;
        }
        // 解锁
        pthread_mutex_unlock(&amp;mutex);
    }

    return NULL;
}

int main()
{
    // 初始化互斥量
    pthread_mutex_init(&amp;mutex, NULL);

    // 创建三个线程
    pthread_t tid1;
    pthread_t tid2;
    pthread_t tid3;
    pthread_create(&amp;tid1, NULL, selltickets, NULL);
    pthread_create(&amp;tid2, NULL, selltickets, NULL);
    pthread_create(&amp;tid3, NULL, selltickets, NULL);
    // 线程连接，回收子线程的资源，阻塞
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);
    pthread_join(tid3, NULL);
    pthread_exit(NULL);     // 退出main进程

    // 释放互斥量资源
    pthread_mutex_destroy(&amp;mutex);
    return 0;
}
</code></pre>
<p><img alt="image-20211024154443063" src="image-20211024154443063.png" /></p>
<h2 id="_28">死锁</h2>
<h3 id="_29">基本概念</h3>
<ul>
<li>一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生<code>死锁</code></li>
<li>两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁</li>
</ul>
<h3 id="_30">死锁的几种场景</h3>
<h4 id="_31">忘记释放锁</h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

// 全局变量，所有的线程都共享这一份资源。
int tickets = 1000;

// 创建一个互斥量
pthread_mutex_t mutex;

void * sellticket(void * arg) {

    // 卖票
    while(1) {
        // 加锁
        pthread_mutex_lock(&amp;mutex);

        if(tickets &gt; 0) {
            usleep(6000);
            printf(&quot;%ld 正在卖第 %d 张门票\n&quot;, pthread_self(), tickets);
            tickets--;
        }else {
            // 解锁
            pthread_mutex_unlock(&amp;mutex);
            break;
        }

    }

    return NULL;
}

int main() 
{
    // 初始化互斥量
    pthread_mutex_init(&amp;mutex, NULL);

    // 创建3个子线程
    pthread_t tid1, tid2, tid3;
    pthread_create(&amp;tid1, NULL, sellticket, NULL);
    pthread_create(&amp;tid2, NULL, sellticket, NULL);
    pthread_create(&amp;tid3, NULL, sellticket, NULL);

    // 回收子线程的资源,阻塞
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);
    pthread_join(tid3, NULL);

    pthread_exit(NULL); // 退出主线程

    // 释放互斥量资源
    pthread_mutex_destroy(&amp;mutex);

    return 0;
}
</code></pre>
<h4 id="_32">重复加锁</h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

// 全局变量，所有的线程都共享这一份资源。
int tickets = 1000;

// 创建一个互斥量
pthread_mutex_t mutex;

void * sellticket(void * arg) {

    // 卖票
    while(1) {

        // 加锁
        pthread_mutex_lock(&amp;mutex);
        pthread_mutex_lock(&amp;mutex);

        if(tickets &gt; 0) {
            usleep(6000);
            printf(&quot;%ld 正在卖第 %d 张门票\n&quot;, pthread_self(), tickets);
            tickets--;
        }else {
            // 解锁
            pthread_mutex_unlock(&amp;mutex);
            break;
        }

        // 解锁
        pthread_mutex_unlock(&amp;mutex);
        pthread_mutex_unlock(&amp;mutex);
    }

    return NULL;
}

int main() {

    // 初始化互斥量
    pthread_mutex_init(&amp;mutex, NULL);

    // 创建3个子线程
    pthread_t tid1, tid2, tid3;
    pthread_create(&amp;tid1, NULL, sellticket, NULL);
    pthread_create(&amp;tid2, NULL, sellticket, NULL);
    pthread_create(&amp;tid3, NULL, sellticket, NULL);

    // 回收子线程的资源,阻塞
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);
    pthread_join(tid3, NULL);

    pthread_exit(NULL); // 退出主线程

    // 释放互斥量资源
    pthread_mutex_destroy(&amp;mutex);

    return 0;
}
</code></pre>
<h4 id="_33">多线程多锁，抢占锁资源</h4>
<p><img alt="image-20211024162356465" src="image-20211024162356465.png" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

// 创建2个互斥量
pthread_mutex_t mutex1, mutex2;

void * workA(void * arg) {

    pthread_mutex_lock(&amp;mutex1);
    sleep(1);
    pthread_mutex_lock(&amp;mutex2);

    printf(&quot;workA....\n&quot;);

    pthread_mutex_unlock(&amp;mutex2);
    pthread_mutex_unlock(&amp;mutex1);
    return NULL;
}


void * workB(void * arg) {
    pthread_mutex_lock(&amp;mutex2);
    sleep(1);
    pthread_mutex_lock(&amp;mutex1);

    printf(&quot;workB....\n&quot;);

    pthread_mutex_unlock(&amp;mutex1);
    pthread_mutex_unlock(&amp;mutex2);

    return NULL;
}

int main() {

    // 初始化互斥量
    pthread_mutex_init(&amp;mutex1, NULL);
    pthread_mutex_init(&amp;mutex2, NULL);

    // 创建2个子线程
    pthread_t tid1, tid2;
    pthread_create(&amp;tid1, NULL, workA, NULL);
    pthread_create(&amp;tid2, NULL, workB, NULL);

    // 回收子线程资源
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);

    // 释放互斥量资源
    pthread_mutex_destroy(&amp;mutex1);
    pthread_mutex_destroy(&amp;mutex2);

    return 0;
}
</code></pre>
<h2 id="_34">读写锁</h2>
<h3 id="_35">基本概念</h3>
<ul>
<li>当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题</li>
<li>在对数据的读写操作中，<strong>更多的是读操作，写操作较少</strong>，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现</li>
<li>读写锁的特点</li>
<li>如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作</li>
<li>如果有其它线程写数据，则其它线程都不允许读、写操作</li>
<li>写是独占的，写的优先级高</li>
</ul>
<h3 id="_36">读写锁相关操作函数</h3>
<ul>
<li>读写锁的类型：<code>pthread_rwlock_t</code></li>
<li>
<p>初始化读写锁：<code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code></p>
</li>
<li>
<p>释放互斥量的资源：<code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code></p>
</li>
<li>读操作加锁：<code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code></li>
<li>读操作尝试加锁：<code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code></li>
<li>写操作加锁：<code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code></li>
<li>写操作尝试加锁：<code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></li>
<li>解锁：<code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code></li>
</ul>
<h3 id="_37">实例：读写锁实现读线程数量大于写线程数量</h3>
<ul>
<li>8个线程操作同一个全局变量。3个线程不定时写这个全局变量，5个线程不定时的读这个全局变量</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

int num = 0;
// 创建读写锁
pthread_rwlock_t rwlock;

void* workA(void* arg) {
    while (1) {
        // 加写锁
        pthread_rwlock_wrlock(&amp;rwlock);
        num++;
        printf(&quot;++write, tid : %ld, num : %d\n&quot;, pthread_self(), num);
        // 解锁
        pthread_rwlock_unlock(&amp;rwlock);
        usleep(100);
    }

    return NULL;
}

void* workB(void* arg) {
    while (1) {
        // 加读锁
        pthread_rwlock_rdlock(&amp;rwlock);
        printf(&quot;===read, tid : %ld, num : %d\n&quot;, pthread_self(), num);
        // 解锁
        pthread_rwlock_unlock(&amp;rwlock);
        usleep(100);
    }

    return NULL;
}

int main()
{
    // 初始化读写锁
    pthread_rwlock_init(&amp;rwlock, NULL);
    // 创建8个线程，3个写线程，5个读线程
    pthread_t wtids[3], rtids[5];
    for (int i = 0; i &lt; 3; i++) {
        pthread_create(&amp;wtids[i], NULL, workA, NULL);
    }
    for (int i = 0; i &lt; 5; i++) {
        pthread_create(&amp;rtids[i], NULL, workB, NULL);
    }

    // 分离，回收资源
    for (int i = 0; i &lt; 3; i++) {
        pthread_detach(wtids[i]);
    }
    for (int i = 0; i &lt; 5; i++) {
        pthread_detach(rtids[i]);
    }
    // 回收读写锁
    pthread_rwlock_destroy(&amp;rwlock);
    // 回收主线程
    pthread_exit(NULL);
}
</code></pre>
<p><img alt="image-20211024164409909" src="image-20211024164409909.png" /></p>
<h2 id="_38">生产者和消费者</h2>
<h3 id="_39">关系模型</h3>
<p><img alt="image-20211024172038707" src="image-20211024172038707.png" /></p>
<h3 id="_40">存在问题</h3>
<ol>
<li>当容器满时，无法继续生产</li>
<li>当容器空时，无法继续消费</li>
<li>多个生产者或消费者时，会出现线程同步问题</li>
</ol>
<h3 id="_41">实例：简易版多生产者多消费者（互斥量，==存在未解决问题==）</h3>
<ul>
<li>
<p>说明</p>
</li>
<li>
<p>当在删除节点时，加锁时机不同可能会导致段错误</p>
</li>
<li>产生错误版在虚拟机下无法产生<code>core</code>文件，以下截图来自服务器，是否使用<code>-g</code>参数都能生成<code>core</code>文件，==可能是线程函数自带能够生成？==</li>
<li>
<p>虚拟机版在<strong>释放互斥锁前添加while死循环</strong>即可正常生成<code>core</code>文件，所以不产生<code>core</code>文件的原因可能是==线程还在运行而互斥锁提前被释放了==</p>
</li>
<li>
<p>正常执行版</p>
</li>
</ul>
<p>```c
  #include <stdio.h>
  #include <pthread.h>
  #include <stdlib.h>
  #include <unistd.h></p>
<p>// 链表作为容器
  struct Node{
      int val;
      struct Node* next;
  };</p>
<p>// 头结点
  struct Node* head = NULL;</p>
<p>// 互斥量
  pthread_mutex_t mutex;</p>
<p>// 头插法增加元素
  void<em> producter(void</em> arg) {
      while (1) {
          pthread_mutex_lock(&amp;mutex);
          struct Node<em> newNode = (struct Node</em>)malloc(sizeof(struct Node));
          newNode-&gt;val = rand() % 1000;
          newNode-&gt;next = head;
          head = newNode;
          printf("add node, num : %d, tid : %ld\n", newNode-&gt;val, pthread_self());
          pthread_mutex_unlock(&amp;mutex);
          usleep(100);
      }
      return NULL;
  }</p>
<p>// 头删法减少元素
  void<em> consumer(void</em> arg) {
      while (1) {
          pthread_mutex_lock(&amp;mutex);
          struct Node* tmp = head;
          // 当链表不为空时，才能删除
          if (head != NULL) {
              head = head-&gt;next;
              printf("del node, num : %d, tid : %ld\n", tmp-&gt;val, pthread_self());
              free(tmp);
              pthread_mutex_unlock(&amp;mutex);
              usleep(100);
          } else {
              pthread_mutex_unlock(&amp;mutex);
          }
      }
      return NULL;
  }</p>
<p>int main()
  {
      // 初始化互斥锁
      pthread_mutex_init(&amp;mutex, NULL);
      // 创建5个生产者线程，和5个消费者线程
      pthread_t products[5], consumes[5];
      for (int i = 0; i &lt; 5; i++) {
          pthread_create(&amp;products[i], NULL, producter, NULL);
          pthread_create(&amp;consumes[i], NULL, consumer, NULL);
      }</p>
<pre><code>  // 分离，回收线程资源
  for (int i = 0; i &lt; 5; i++) {
      pthread_detach(products[i]);
      pthread_detach(consumes[i]);
  }

  // 回收互斥锁
  pthread_mutex_destroy(&amp;mutex);
  pthread_exit(NULL);     // 回收主线程
  return 0;
</code></pre>
<p>}
  ```</p>
<p><img alt="image-20211024183604991" src="image-20211024183604991.png" /></p>
<ul>
<li>产生错误版（==原因还不清晰，后续再看==）</li>
</ul>
<p>```c
  #include <stdio.h>
  #include <pthread.h>
  #include <stdlib.h>
  #include <unistd.h></p>
<p>// 链表作为容器
  struct Node{
      int val;
      struct Node* next;
  };</p>
<p>// 头结点
  struct Node* head = NULL;</p>
<p>// 互斥量
  pthread_mutex_t mutex;</p>
<p>// 头插法增加元素
  void<em> producter(void</em> arg) {
      while (1) {
          pthread_mutex_lock(&amp;mutex);
          struct Node<em> newNode = (struct Node</em>)malloc(sizeof(struct Node));
          newNode-&gt;val = rand() % 1000;
          newNode-&gt;next = head;
          head = newNode;
          printf("add node, num : %d, tid : %ld\n", newNode-&gt;val, pthread_self());
          pthread_mutex_unlock(&amp;mutex);
          usleep(100);
      }
      return NULL;
  }</p>
<p>// 头删法减少元素
  void<em> consumer(void</em> arg) {
      while (1) {
          // 如果只在头结点不为空的情况下使用互斥锁会产生段错误，暂未找到原因
          if (head != NULL) {
              pthread_mutex_lock(&amp;mutex);
              struct Node* tmp = head;
              head = head-&gt;next;
              printf("del node, num : %d, tid : %ld\n", tmp-&gt;val, pthread_self());
              free(tmp);
              tmp = NULL;
              pthread_mutex_unlock(&amp;mutex);
              usleep(100);
          }
      }
      return NULL;
  }</p>
<p>int main()
  {
      // 初始化互斥锁
      pthread_mutex_init(&amp;mutex, NULL);
      // 创建5个生产者线程，和5个消费者线程
      pthread_t products[5], consumes[5];
      for (int i = 0; i &lt; 5; i++) {
          pthread_create(&amp;products[i], NULL, producter, NULL);
          pthread_create(&amp;consumes[i], NULL, consumer, NULL);
      }</p>
<pre><code>  // 分离，回收线程资源
  for (int i = 0; i &lt; 5; i++) {
      pthread_detach(products[i]);
      pthread_detach(consumes[i]);
  }

  // 加while循环即可在虚拟机中生成core文件
  // while (1) {
  //     sleep(10);
  // }
  // 回收互斥锁
  pthread_mutex_destroy(&amp;mutex);
  pthread_exit(NULL);     // 回收主线程
  return 0;
</code></pre>
<p>}
  ```</p>
<ul>
<li>
<p>服务器</p>
<p><img alt="image-20211024190914068" src="image-20211024190914068.png" /></p>
<p><img alt="image-20211024191441756" src="image-20211024191441756.png" /></p>
</li>
<li>
<p>虚拟机</p>
<p><img alt="image-20211024192925831" src="image-20211024192925831.png" /></p>
<p><img alt="image-20211024192944475" src="image-20211024192944475.png" /></p>
</li>
</ul>
<h2 id="_42">条件变量</h2>
<h3 id="_43">条件变量相关操作函数</h3>
<ul>
<li>当满足条件时，才执行，不是锁，配合互斥量使用</li>
<li>条件变量的类型：<code>pthread_cond_t</code></li>
<li>初始化：<code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code></li>
<li>回收：<code>int pthread_cond_destroy(pthread_cond_t *cond);</code></li>
<li>等待，调用了该函数，线程会阻塞：<code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code></li>
<li>等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束：<code>int pthread_cond_timedwait(pthread_cond_t *restrict cond,  pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</code></li>
<li>唤醒一个或者多个等待的线程：<code>int pthread_cond_signal(pthread_cond_t *cond);</code></li>
<li>唤醒所有的等待的线程：<code>int pthread_cond_broadcast(pthread_cond_t *cond);</code></li>
</ul>
<h3 id="_44">实例：条件变量下的多生产者多消费者</h3>
<ul>
<li>当有生产者生产时，通知消费者消费，否则等待</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

// 链表作为容器
struct Node{
    int val;
    struct Node* next;
};

// 头结点
struct Node* head = NULL;

// 互斥量
pthread_mutex_t mutex;
// 条件变量
pthread_cond_t cond;

// 头插法增加元素
void* producter(void* arg) {
    while (1) {
        pthread_mutex_lock(&amp;mutex);
        struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
        newNode-&gt;val = rand() % 1000;
        newNode-&gt;next = head;
        head = newNode;
        printf(&quot;add node, num : %d, tid : %ld\n&quot;, newNode-&gt;val, pthread_self());

        // 只要生产了一个，就通知消费者消费
        pthread_cond_signal(&amp;cond);

        pthread_mutex_unlock(&amp;mutex);
        usleep(100);
    }
    return NULL;
}

// 头删法减少元素
void* consumer(void* arg) {
    while (1) {
        pthread_mutex_lock(&amp;mutex);
        struct Node* tmp = head;
        // 当链表不为空时，才能删除
        if (head != NULL) {
            head = head-&gt;next;
            printf(&quot;del node, num : %d, tid : %ld\n&quot;, tmp-&gt;val, pthread_self());
            free(tmp);
            pthread_mutex_unlock(&amp;mutex);
            usleep(100);
        } else {
            // 没有数据，需要等待
            // 当这个函数调用阻塞的时候，会对互斥锁进行解锁，当不阻塞的，继续向下执行，会重新加锁。
            pthread_cond_wait(&amp;cond, &amp;mutex);
            pthread_mutex_unlock(&amp;mutex);
        }
    }
    return NULL;
}

int main()
{
    // 初始化互斥锁
    pthread_mutex_init(&amp;mutex, NULL);
    // 初始化条件变量
    pthread_cond_init(&amp;cond, NULL);
    // 创建5个生产者线程，和5个消费者线程
    pthread_t products[5], consumes[5];
    for (int i = 0; i &lt; 5; i++) {
        pthread_create(&amp;products[i], NULL, producter, NULL);
        pthread_create(&amp;consumes[i], NULL, consumer, NULL);
    }

    // 分离，回收线程资源
    for (int i = 0; i &lt; 5; i++) {
        pthread_detach(products[i]);
        pthread_detach(consumes[i]);
    }

    while (1) {
        sleep(10);
    }
    // 回收条件变量
    pthread_cond_destroy(&amp;cond);
    // 回收互斥锁
    pthread_mutex_destroy(&amp;mutex);
    pthread_exit(NULL);     // 回收主线程
    return 0;
}
</code></pre>
<p><img alt="image-20211024204722129" src="image-20211024204722129.png" /></p>
<h2 id="_45">信号量</h2>
<h3 id="_46">信号量相关操作函数</h3>
<ul>
<li>信号量的类型：<code>sem_t</code></li>
<li><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code></li>
<li>功能：初始化信号量</li>
<li>参数<ul>
<li><code>sem</code>：信号量变量的地址</li>
<li><code>pshared</code>：0 用在线程间 ，非0 用在进程间</li>
<li><code>value</code>：信号量中的值，代表容器大小</li>
</ul>
</li>
<li><code>int sem_destroy(sem_t *sem);</code></li>
<li>功能：释放资源</li>
<li><code>int sem_wait(sem_t *sem);</code></li>
<li>功能：对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞</li>
<li><code>int sem_trywait(sem_t *sem);</code></li>
<li><code>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</code></li>
<li><code>int sem_post(sem_t *sem);</code></li>
<li>功能：对信号量解锁，调用一次对信号量的值+1</li>
<li><code>int sem_getvalue(sem_t *sem, int *sval);</code></li>
</ul>
<h3 id="_47">实例：信号量下的多生产者多消费者</h3>
<ul>
<li>不需要单独判断<code>容器</code>为空的情况</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;semaphore.h&gt;

// 链表作为容器
struct Node{
    int val;
    struct Node* next;
};

// 头结点
struct Node* head = NULL;

// 互斥量
pthread_mutex_t mutex;
// 信号量
sem_t psem;
sem_t csem;

// 头插法增加元素
void* producter(void* arg) {
    while (1) {
        sem_wait(&amp;psem);
        pthread_mutex_lock(&amp;mutex);
        struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
        newNode-&gt;val = rand() % 1000;
        newNode-&gt;next = head;
        head = newNode;
        printf(&quot;add node, num : %d, tid : %ld\n&quot;, newNode-&gt;val, pthread_self());
        pthread_mutex_unlock(&amp;mutex);
        sem_post(&amp;csem);
    }
    return NULL;
}

// 头删法减少元素
void* consumer(void* arg) {
    while (1) {
        sem_wait(&amp;csem);
        pthread_mutex_lock(&amp;mutex);
        struct Node* tmp = head;
        // 当链表不为空时，才能删除
        if (head != NULL) {
            head = head-&gt;next;
            printf(&quot;del node, num : %d, tid : %ld\n&quot;, tmp-&gt;val, pthread_self());
            free(tmp);
            pthread_mutex_unlock(&amp;mutex);
            sem_post(&amp;psem);
        }
    }
    return NULL;
}

int main()
{
    // 初始化互斥锁
    pthread_mutex_init(&amp;mutex, NULL);
    // 初始化信号量
    // 最多生产8个
    sem_init(&amp;psem, 0, 8);
    // 初始没有东西可以消费
    sem_init(&amp;csem, 0, 0);

    // 创建5个生产者线程，和5个消费者线程
    pthread_t products[5], consumes[5];
    for (int i = 0; i &lt; 5; i++) {
        pthread_create(&amp;products[i], NULL, producter, NULL);
        pthread_create(&amp;consumes[i], NULL, consumer, NULL);
    }

    // 分离，回收线程资源
    for (int i = 0; i &lt; 5; i++) {
        pthread_detach(products[i]);
        pthread_detach(consumes[i]);
    }

    while (1) {
        sleep(10);
    }
    // 回收信号量
    sem_destroy(&amp;csem);
    sem_destroy(&amp;psem);
    // 回收互斥锁
    pthread_mutex_destroy(&amp;mutex);
    pthread_exit(NULL);     // 回收主线程
    return 0;
}
</code></pre>
<p><img alt="image-20211024211933732" src="image-20211024211933732.png" /></p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
